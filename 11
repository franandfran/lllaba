%==========================================================================
% Yuta Tanisumi
% 250718~
%
% < thema >
%
% < usage > Let's jump to "WORKSPACE" [Ctrl + D]
%
% < need >
%
% < ref >
%
% < log >
% tutorial_corrCellCell_temp >>>
% tutorial_corrCellCell_tempForAolin
%==========================================================================


function tutorial_corrCellCell_tempForAolin(varargin)
%% load ... Sections separated by "%%" can be run using "Run Section" or click-&-Ctrl+Enter
%           Or select codes and run via right-click or F9
%           "%%" で区切られたセクション内は、「セクションの実行」か click-&-CTRLキー+Enterキー でプログラム実行される


% default_params = {
% 
% 'XXX', 'YYY';...
% 
% };
% try params = parse_args_local( default_params, varargin{:} ); catch; params = parse_args_local( default_params, [] ); end
% 

% % 


% Y:\RawData_img\Aolin\250702BD6789prePSL
% Y:\RawData_img\Aolin\250702BD6789prePSL\P6-baseline-pre\suite2p\plane0
[PCid, p] = loadPCinfo; cd(p.path_NAS2);
%=== SELECT ===============================================================
DATABASE = loadSessionData; % Select Fall.m (ROIcuration.m must be in the same folder) | Fall.m を選択（同じフォルダ内にROIcuration.mが必要）
%==========================================================================


Fcell = DATABASE.DATA.Fcell(DATABASE.DATA.ResROIrefine.rows_neuron, :); % Reflect the number of ROIs after ROI-curation | ROI-curation の結果を反映したROI数に
figure(1); TracePlot(Fcell, 'ROIid', DATABASE.DATA.ResROIrefine.s2pids_neuron); title(DATABASE.DATA.path_database); % Check traces
% > Also check spatial information | +位置情報もチェック
SpaceMap = getSpaceMapFromSuite2pFallStat(DATABASE.DATA, 'Suite2pID_target', DATABASE.DATA.ResROIrefine.rows_neuron);
figure; imagesc(SpaceMap.masks); hold on; FaceColors = YTcm('viridis', 'Nbin', length(DATABASE.DATA.ResROIrefine.rows_neuron), 'setgca', 'off'); colormap([[0 0 0]; FaceColors]); colorbar;
for row = 1:SpaceMap.Nroi; text(SpaceMap.centroidsXY_Area(row,1), SpaceMap.centroidsXY_Area(row,2), num2str(DATABASE.DATA.ResROIrefine.s2pids_neuron(row)), 'Color', 'w', 'HorizontalAlignment', 'center'); end


%% cal


%=== SELECT ===============================================================
useFrames = 1: 1200; % Specify the frame range to evaluate traces | trace評価に使用するフレーム数を指定
%==========================================================================


Fcell_target = Fcell(:, useFrames);
ResWeval = evalTraceWlabStandard(Fcell_target, 'Hz', DATABASE.DATA.Hz); % Classic trace evaluation code from WAKElab | WAKElab に昔からある trace評価コード
ReSPONT = evalTraceSponta(Fcell_target, 'Hz', DATABASE.DATA.Hz); % Trace evaluation code created by Tanisumi | 谷隅作 trace評価コード
% [ResCorr, input] = evalTraceCorr(TraceMat, EventFile_HoloStimOnset, 'LagSec', params.LagSec, 'LagSec_eval', DATABASE.params.evalWinSec, 'Hz', params.Hz);
% Trace evaluation results are stored in "ResWeval" | trace評価結果は "ResWeval" に格納されている
ResWeval.TracePower
ResWeval.FiringFrequency % [Hz] : FiringNumber / Sec
ResWeval.FiringAmplitude
ResWeval.CorrCosineAllPairs
% ReSPONT.ReSpont
% ReSPONT.ReSpontCorr
% > Save results to .mat file for later inspection, Drag .mat file into workspace to view contents | 計算結果を変数として保存するなら。保存したmatfileをワークスペースにドラッグアンドドロップすると、中身の数値を確認可能
ResBasicTrace = struct; ResBasicTrace.ResWeval = ResWeval; ResBasicTrace.ReSPONT = ReSPONT; ResBasicTrace.useFrames = useFrames;
cd(DATABASE.DATA.path_database); [path_save, path_mother, filename] = uisave('temp', 'ResBasicTrace_XXX', 'ext', "mat", 'data', ResBasicTrace); 


% > quick-viewer
KEYlist = ["TracePower", "FiringFrequency", "FiringAmplitude", "CorrCosineAllPairs"];
figure; 
tiledlayout(1, numel(KEYlist));
for i = 1:numel(KEYlist)
    nexttile; KEY = KEYlist(i); vioplot(ResWeval.(KEY), 'jitterspacing', .2, 'bins', 30); title(['ResWeval.', char(KEY)]);
end


%% viewer+


% TraceMat = out.DATA.Fcell(rows_target, :);
% CL2 = clustFiringPattern(TraceMat, 'method', 'kmeans++', 'Nclust', 12); [ val, idx ] = sort(CL2.rslt_idx);
TraceMat_target = Fcell'; TraceMat_target(isnan(TraceMat_target)) = 0;
TraceMat_buddy = Fcell'; TraceMat_buddy(isnan(TraceMat_buddy)) = 0;
[ R, P ] = corr( TraceMat_target./max(max(TraceMat_target)), TraceMat_buddy./max(max(TraceMat_buddy)) );
% figure; imagesc(R);
Y = 1 - R;                             % Convert to distance matrix (higher correlation = smaller distance) | 距離行列に変換（相関が高いほど距離が小さい）
Y = (Y + Y') / 2;                      % Symmetrize the matrix just in case | 念のため対称化
Y(logical(eye(size(Y)))) = 0;          % Set diagonal values to 0 | 対角を 0 にする
Z = linkage(squareform(Y), 'average'); % Convert to distance vector suitable for linkage | linkage に渡せる距離ベクトルに変換
leafOrder = optimalleaforder(Z, Y);  
figure; 
imagesc(R(leafOrder, leafOrder));
D = diag( ones(size(R,1), 1) );
Rpair = R(D==1);
Rother = reshape(R(D==0), [], 1);
YTcm('ykc'); colorbar;
clim([-.5 .5]);
% clim([-1 1]);
disp([ mean(Rpair) mean(Rother) ]);
title({ DATABASE.DATA.path_database; ['PeasonR : AllPair-Mean = ', num2str(round(mean(Rother), 2))] }); 
set(gca, 'Ydir', 'normal');


% %% corr
% 
% 
% % figure; scatter(TE.TrialParams.SLM.XYlist(:,1), TE.TrialParams.SLM.XYlist(:,2)); xlim([1 512]); ylim([1 512]); text(TE.TrialParams.SLM.XYlist(:,1), TE.TrialParams.SLM.XYlist(:,2), string(1:size(TE.TrialParams.SLM.XYlist,1))); set(gca, 'Ydir', 'reverse');
% 
% LOAD = load("G:\マイドライブ\SharedCodesSmee\SpatialLightModulators\TraceMatFileForSLMpattern\TraceMatFileForSLMpattern_temp.mat");
% TraceMat_target = LOAD.TraceMatFileForSLMpattern.ROIxFRAMEmat; 
% Nroi = size(TraceMat_target,1); Nframe = size(TraceMat_target,2);
% % figure; base = 1; for row = 1:size(TraceMat_target,1); Y = TraceMat_target(row,:); Y = Y/max(Y); plot(Y+base*row); hold on; end
% 
% % [ filename, dirpath ] = uigetfile( ".csv", 'Select a CSVfile' ); path_CSVfile = [ dirpath, filename ]; LOAD = load(path_BpodMatFile); TE = LOAD.TE; cd(dirpath);
% % TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\WT95\231217\ImgJtrace\TraceMat_WT95_231217_112528_HfixHoloCS__ID_WT95-f1-z150_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% % S = 580; PLUS = 1600;
% % TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\WT95\231217\ImgJtrace\TraceMat_WT95_231217_113733_HfixHoloCS__ID_WT95-f1-z150_231217_2-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% 
% % TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA36\231217\ImgJtrace\TraceMat_KA36_231218_025834_HfixHoloCS__ID_KA36-f01-z80_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% % S = 460; PLUS = 1300; % KA36: (1) (2)
% 
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\WT95\231217\ImgJtrace\TraceMat_WT95_231217_192220_HfixHoloCS__ID_WT95-f1-z150_231217_3-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 650; PLUS = 1600; % WT95: 1 2 4 5 7 8 9
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA16\231217\ImgJtrace\TraceMat_KA16_231217_220612_HfixHoloCS__ID_KA16-f2-z135_231217_4-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 600; PLUS = 1300; % KA16: 1 2 3 (4) 5 6 7 8 9
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA15\231217\ImgJtrace\TraceMat_KA15_231218_000235_HfixHoloCS__ID_KA15-f1-z120_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 500; PLUS = 1300; % KA15: 1 2 3 4 5 6 7 8 9
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA33\231217\ImgJtrace\TraceMat_KA33_231218_005346_HfixHoloCS__ID_KA33-f1-z120_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 600; PLUS = 1600; % KA33: 1 2 (3) 4 5 6 (7) 8 | 10
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA22\231217\ImgJtrace\TraceMat_KA22_231218_021508_HfixHoloCS__ID_KA22-f01-z130_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 460; PLUS = 1350; % KA22: 1 2 (3) 4 5 6 (7) 8 | 9 (10)
% 
% TraceMat_buddy = TraceMat_buddy(2:11,:);
% % Nroi = size(TraceMat_buddy,1); Nframe = size(TraceMat_buddy,2);
% % figure; base = 1; for row = 1:size(TraceMat_buddy,1); Y = TraceMat_buddy(row,:); Y = Y/max(Y); plot(Y+base*row); hold on; end
% % xlim([620 1620]);
% % xlim([620 2220]);
% % S = 620;
% cols = round(linspace(S, S+PLUS, 1000));
% TraceMat_buddy_cut = TraceMat_buddy(:,cols);
% % xline(180);
% 
% % TraceMat_buddy_adj = TraceMat_buddy;
% % % TraceMat_buddy_adj = TraceMat_buddy(:,670:1669);
% % figure; base = 1; for row = 1:size(TraceMat_buddy_adj,1); Y = TraceMat_buddy_adj(row,:); Y = Y/max(Y); plot(Y+base*row); hold on; end
% % xlim([1 1000]);
% 
% 
% target = TraceMat_target./max(max(TraceMat_target));
% % target = TraceMat_target;
% buddy = TraceMat_buddy_cut./max(max(TraceMat_buddy_cut));
% % buddy = TraceMat_buddy_cut;
% % buddy = TraceMat_buddy_adj./max(max(TraceMat_buddy_adj));
% % params.SpikeThrSD = 1.96;
% % params.SLMpatternBinWidthSec = 0.06;
% % [~, ~, target] = exchangerTraceToBinary(target, params);
% % [~, ~, buddy] = exchangerTraceToBinary(buddy, params);
% % [target] = exchangerTraceToBinary(target, params);
% % [buddy] = exchangerTraceToBinary(buddy, params);
% 
% 
% figure;
% subplot(2,1,1); base = 1; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+base*row); hold on; end
% subplot(2,1,2); base = 1; for row = 1:size(buddy,1); Y = buddy(row,:); Y = Y/max(Y); plot(Y+base*row); hold on; end
% [ R, P ] = corr(target', buddy');
% figure; imagesc(R);  
% 
% D = diag( ones(size(R,1), 1) );
% Rpair = R(D==1);
% Rother = reshape(R(D==0), [], 1);
% disp([ mean(Rpair) mean(Rother) ]);
% % figure; bar([mean(Rpair) mean(Rother)]);
% disp(Rpair);
% 
% 
% %% sum
% 
% 
% LOAD = load("G:\マイドライブ\SharedCodesSmee\SpatialLightModulators\TraceMatFileForSLMpattern\TraceMatFileForSLMpattern_temp.mat");
% TraceMat_target = LOAD.TraceMatFileForSLMpattern.ROIxFRAMEmat; 
% LOAD = load("G:\マイドライブ\SharedCodesSmee\SpatialLightModulators\TraceMatFileForSLMpattern\@bk\TraceMatFileForSLMpattern_temp.mat");
% TraceMat_target_orig = LOAD.TraceMatFileForSLMpattern.ROIxFRAMEmat; 
% TraceMat_target_ctrl = TraceMat_target_orig(:,5001:6000);
% 
% 
% rows = 2:11;
% order = [1 2 5 8];
% order = [1 2 4 5 6 8 9];
% rows = rows(order);
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\WT95\231217\ImgJtrace\TraceMat_WT95_231217_192220_HfixHoloCS__ID_WT95-f1-z150_231217_3-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 650; PLUS = 1600; % WT95: 1 2 4 5 7 8 9
% cols = round(linspace(S, S+PLUS, 1000)); TraceMat_buddy_eg1 = TraceMat_buddy(rows,cols);
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA16\231217\ImgJtrace\TraceMat_KA16_231217_220612_HfixHoloCS__ID_KA16-f2-z135_231217_4-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 600; PLUS = 1300; % KA16: 1 2 3 (4) 5 6 7 8 9
% cols = round(linspace(S, S+PLUS, 1000)); TraceMat_buddy_eg2 = TraceMat_buddy(rows,cols);
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA15\231217\ImgJtrace\TraceMat_KA15_231218_000235_HfixHoloCS__ID_KA15-f1-z120_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 500; PLUS = 1300; % KA15: 1 2 3 4 5 6 7 8 9
% cols = round(linspace(S, S+PLUS, 1000)); TraceMat_buddy_eg3 = TraceMat_buddy(rows,cols);
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA33\231217\ImgJtrace\TraceMat_KA33_231218_005346_HfixHoloCS__ID_KA33-f1-z120_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 600; PLUS = 1600; % KA33: 1 2 (3) 4 5 6 (7) 8 | 10
% cols = round(linspace(S, S+PLUS, 1000)); TraceMat_buddy_eg4 = TraceMat_buddy(rows,cols);
% TraceMat_buddy = readmatrix("G:\マイドライブ\database\database_HfixHoloCS\KA22\231217\ImgJtrace\TraceMat_KA22_231218_021508_HfixHoloCS__ID_KA22-f01-z130_231217_1-Write_onlyStim_NaNg.csv")'; % ChRmine: receiver 
% S = 460; PLUS = 1350; % KA22: 1 2 (3) 4 5 6 (7) 8 | 9 (10)
% cols = round(linspace(S, S+PLUS, 1000)); TraceMat_buddy_eg5 = TraceMat_buddy(rows,cols);
% 
% 
% flag_exportPDF = 1;
% % CL = YTcm( 'phase', 'Nbin', length(order), 'setgca', 'off' );
% CL = YTcm( 'vi', 'Nbin', length(order), 'setgca', 'off' );
% [ fig, ax, iAX, LBWH, Btop, Lright ] = YTpfig( 'figType', 'landscape', 'TickLengthCM', 2 ); LBWH(1) = LBWH(1) + 1.2; COUNTER = 0; % fig.PaperPosition
% subplot(1,6,1); target = TraceMat_target(order,:); for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% subplot(1,6,2); target = TraceMat_buddy_eg1; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% subplot(1,6,3); target = TraceMat_buddy_eg2; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% subplot(1,6,4); target = TraceMat_buddy_eg3; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% subplot(1,6,5); target = TraceMat_buddy_eg4; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% subplot(1,6,6); target = TraceMat_buddy_eg5; for row = 1:size(target,1); Y = target(row,:); Y = Y/max(Y); plot(Y+row, 'Color', CL(row,:)); hold on; end; set(gca, 'XColor', 'none', 'YColor', 'none', 'box', 'off');
% if flag_exportPDF; filename = fullfile(getpath_desktop, ['sample_', YTdate]); print( fig, '-painters', '-r450', filename, '-dpdf' ); disp( [ '>>> PDF saved  ', filename ] ); end
% 
% %%
% flag_exportPDF = 1;
% [ R_eg1, P ] = corr(TraceMat_target(order,:)', TraceMat_buddy_eg1'); D = diag(ones(size(R_eg1))); Rpair_eg1 = R_eg1(D==1); [RpairMax_eg1, RpairMax_eg1_idx] = max(Rpair_eg1); [ R_eg1_ctrl, P ] = corr(TraceMat_target_ctrl(order,:)', TraceMat_buddy_eg1'); Rpair_eg1_ctrl = R_eg1_ctrl(D==1);
% [ R_eg2, P ] = corr(TraceMat_target(order,:)', TraceMat_buddy_eg2'); Rpair_eg2 = R_eg2(D==1); [RpairMax_eg2, RpairMax_eg2_idx] = max(Rpair_eg2); [ R_eg2_ctrl, P ] = corr(TraceMat_target_ctrl(order,:)', TraceMat_buddy_eg2'); Rpair_eg2_ctrl = R_eg2_ctrl(D==1);
% [ R_eg3, P ] = corr(TraceMat_target(order,:)', TraceMat_buddy_eg3'); Rpair_eg3 = R_eg3(D==1); [RpairMax_eg3, RpairMax_eg3_idx] = max(Rpair_eg3); [ R_eg3_ctrl, P ] = corr(TraceMat_target_ctrl(order,:)', TraceMat_buddy_eg3'); Rpair_eg3_ctrl = R_eg3_ctrl(D==1);
% [ R_eg4, P ] = corr(TraceMat_target(order,:)', TraceMat_buddy_eg4'); Rpair_eg4 = R_eg4(D==1); [RpairMax_eg4, RpairMax_eg4_idx] = max(Rpair_eg4); [ R_eg4_ctrl, P ] = corr(TraceMat_target_ctrl(order,:)', TraceMat_buddy_eg4'); Rpair_eg4_ctrl = R_eg4_ctrl(D==1);
% [ R_eg5, P ] = corr(TraceMat_target(order,:)', TraceMat_buddy_eg5'); Rpair_eg5 = R_eg5(D==1); [RpairMax_eg5, RpairMax_eg5_idx] = max(Rpair_eg5); [ R_eg5_ctrl, P ] = corr(TraceMat_target_ctrl(order,:)', TraceMat_buddy_eg5'); Rpair_eg5_ctrl = R_eg5_ctrl(D==1);
% [ fig, ax, iAX, LBWH, Btop, Lright ] = YTpfig( 'figType', 'landscape', 'TickLengthCM', 2 ); LBWH(1) = LBWH(1) + 1.2; YLIM = [-.3 .7]; YTICKS = [ -0.2 0 0.2 0.4 0.6 ]; FS = 17; LW = 1.5; ColorSet = YTcm('phase', 'Nbin', 5, 'setgca', 'off');
% gData = { [ RpairMax_eg1, RpairMax_eg2, RpairMax_eg3, RpairMax_eg4, RpairMax_eg5 ], [ Rpair_eg1_ctrl(RpairMax_eg1_idx), Rpair_eg2_ctrl(RpairMax_eg2_idx), Rpair_eg3_ctrl(RpairMax_eg3_idx), Rpair_eg4_ctrl(RpairMax_eg4_idx), Rpair_eg5_ctrl(RpairMax_eg5_idx) ] }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'ColorSet', ColorSet, 'mode', 'beeswarm', 'show', 'median', 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% % subplot(1,5,1); gData = { Rpair_eg1, Rpair_eg1_ctrl }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'mode', 'beeswarm', 'show', 'median', 'CM', YTcgrad( [ YTc('r'); YTc('k') ] ), 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% ylabel('Correlation coefficient R');
% % subplot(1,5,2); gData = { Rpair_eg2, Rpair_eg2_ctrl }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'mode', 'beeswarm', 'show', 'median', 'CM', YTcgrad( [ YTc('r'); YTc('k') ] ), 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% % subplot(1,5,3); gData = { Rpair_eg3, Rpair_eg3_ctrl }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'mode', 'beeswarm', 'show', 'median', 'CM', YTcgrad( [ YTc('r'); YTc('k') ] ), 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% % subplot(1,5,4); gData = { Rpair_eg4, Rpair_eg4_ctrl }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'mode', 'beeswarm', 'show', 'median', 'CM', YTcgrad( [ YTc('r'); YTc('k') ] ), 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% % subplot(1,5,5); gData = { Rpair_eg5, Rpair_eg5_ctrl }; gData_label = ["vs. sender's signal", "vs. sender's sponta."]; ResStat =  YTplot_group( gData, gData_label, 'mode', 'beeswarm', 'show', 'median', 'CM', YTcgrad( [ YTc('r'); YTc('k') ] ), 'LW', LW); ylim(YLIM); yticks(YTICKS); yline(0); set(gca, 'FontSize', FS);
% if flag_exportPDF; filename = fullfile(getpath_desktop, ['sample_', YTdate]); print( fig, '-painters', '-r450', filename, '-dpdf' ); disp( [ '>>> PDF saved  ', filename ] ); end

                    
end % main


%==========================================================================
% > core
function [BinaryMat, BinaryMat_X, SpikeMat, SpikeMat_X] = exchangerTraceToBinary(TraceMatFileForSLMpattern, params)
 ylim(YLIM);%%
% ref: find_spike, SpikeDetection, ...samecellcoscorr, Cross_correlation3


% TraceMat_target = TraceMatFileForSLMpattern.ROIxFRAMEmat;
% Hz = TraceMatFileForSLMpattern.Hz;
TraceMat_target = TraceMatFileForSLMpattern;
Hz = 30;


[Nroi, Nframe] = size(TraceMat_target);
SpikeMat = zeros(Nroi,Nframe);
for i= 1:Nroi
    SpikeMat(i,:) = find_spike(TraceMat_target(i,:), params.SpikeThrSD);
end
BinWidth = 1/Hz;
SpikeMat_X = ( BinWidth:BinWidth:Nframe*BinWidth ) - BinWidth/2;
% countWindow = [ input_X(1) input_X(end) ];
countWindow = [ 0 Nframe*BinWidth ];
bc = Bincount(SpikeMat, SpikeMat_X, params.SLMpatternBinWidthSec, countWindow);
BinaryMat = bc.countMat;
BinaryMat_X = bc.binXvals;


flag_view = 0;
if flag_view==1
    figure;
    subplot(2,1,1); imagesc(SpikeMat); set(gca, 'Ydir', 'normal');
    subplot(2,1,2); imagesc(BinaryMat); set(gca, 'Ydir', 'normal');    
    figure;
    for i = 1:Nroi
        subplot(ceil(Nroi/3),3,i);
        plot(TraceMat_target(i,:));
        hold on;
        idx = find(SpikeMat(i,:));
        Val = TraceMat_target(i,idx);
        scatter(idx, Val);
        hold on;
        thr = mean(TraceMat_target(i,:)) + params.SpikeThrSD * std(TraceMat_target(i,:));
        plot(thr * ones(1,Nframe));
    end
end


function spike = find_spike(trace, coef)
    thr = mean(trace) + coef*std(trace);
%     thr = prctile(trace, 35); % 35%
    dif = [zeros(1,1),diff(trace)];
    tmp = movprod(dif,[0 1]);
    tmp(1) = 0;
    tmp(end) = 0;
    spike = (tmp < 0) .* (dif > 0) .* (trace > thr);
end


end
function bc = Bincount(input, input_X, binParamsSec, countWindow) % input_X = [ (1/30):(1/30):6000*(1/30) ]; binParamsSec = [ 0.06 ]; countWindow = [ input_X(1) input_X(end) ];
%%

% countWindow = [ -3 3 ]; binParamsSec = [ 0.05, 0.005 ]; % def : 50msec, shift 5msec


% make binWindows
if length(binParamsSec)==2  % for mutual information    
        bc.mode = 'shift';
        binWins = [];
        binSize = binParamsSec(1);
        binShift = binParamsSec(2);
        binWins_left = countWindow(1):binShift:countWindow(2);
        binWins_right = binWins_left + binSize;
        OKflag = binWins_right<=countWindow(2);
        binWins = [ binWins_left(OKflag)', binWins_right(OKflag)' ];    
        bc.binSizeSec = binSize;
        bc.binShiftSec = binShift;        
elseif length(binParamsSec)==1  % standard for psth...     
        bc.mode = 'standard';
        binSize = binParamsSec(1);     
        binWins_left = countWindow(1):binSize:countWindow(2);
        binWins_right = binWins_left + binSize;
        OKflag = binWins_right<=countWindow(2);
        binWins = [ binWins_left(OKflag)', binWins_right(OKflag)' ];       
        bc.binSizeSec = binSize;                
end
binXvals = mean( binWins, 2 );
OKflag = ( round( countWindow(1), 4 ) <= round( binWins( :, 1 ), 4 ) )&( round( binWins( :, 2 ), 4 ) <= round( countWindow(2), 4 ) ); % round 0.1 msec
binXvals = binXvals(OKflag);
binXvals = reshape(binXvals, 1, []);
binWins = binWins(OKflag, :);
binNum = size(binWins, 1);


% count spike    
if iscell(input)
    Ntrials = length(input);
    countMat = zeros(Ntrials, binNum);
    for t = 1:Ntrials
        spike = input{t};
        if isempty(spike)==0
            for bn = 1:binNum
                bw = binWins( bn, : );
                countMat( t, bn ) = nansum( double( ( bw(1) < spike )&( spike <= bw(2) ) ) );
            end
        end
    end
elseif ismatrix(input)
    ValMat = input; % roi x time
    Nroi = size(ValMat,1);
    countMat = zeros( Nroi, size(binWins,1) );
    for roi = 1:Nroi
        ValTrain = input(roi,:);
        for bn = 1:binNum
            [flag_X, X_valid, Y_valid] = getWinFlagX(input_X, binWins(bn,:), 'Y', ValTrain);
            COUNT = sum(Y_valid);
            countMat(roi, bn) = COUNT;
        end
    end    
end % figure; imagesc(binXvals, 1:Nroi, countMat); colorbar;


% % unique
% uCell = cell( 1, binNum );
% for u = 1:binNum
%     countCol = countMat( :, u );
%     vals = unique(countCol);
%     uBox = zeros( length(vals), 2 );
%     for v = 1:length(vals)
%         val = vals(v);
%         vNum = nansum( double( val==countCol ) );
%         uBox( v, : ) = [ val, vNum ];
%     end
%     uCell(u) = { uBox };    
% end


%% output
bc.countWindow = countWindow;
bc.binWins = binWins;
bc.binXvals = binXvals;
bc.countMat = countMat;
bc.binNum = binNum;
bc.input = input;


end


% >> 'EventAlign'
function results = createValMatAroundTrigger( FallMat, EventFile1D, params )
%% cal


% > basic
results = struct;
switch params.EventFifeType
    case 'Onset'
        EventFile1D_onset = [ 0 diff( reshape(EventFile1D, 1, []) ) ] > 0;
        X_Trigger01 = EventFile1D_onset;
%         X_Trigger01 = EventFile1D; % figure; plot(X_Trigger01);
end      
Nbin = length(X_Trigger01);
results.Nroi = FallMat.Nroi_ok;
results.Ntrigger = nansum(X_Trigger01);
results.X_Trigger01 = X_Trigger01;
results.ColsTrigger = find(X_Trigger01);
results.X_BinWidthMeanSec = 1/params.FrameHz;
X_BinNum_MinusWin = round( diff( [ params.WindowSec(1)-1 0 ] ) / results.X_BinWidthMeanSec );
X_BinNum_PlusWin = round( diff( [ 0 params.WindowSec(2)+1 ] ) / results.X_BinWidthMeanSec );
results.X_ValMat = [ -X_BinNum_MinusWin:1:0, 1:1:X_BinNum_PlusWin ] * results.X_BinWidthMeanSec;
results.Y_Ntrigger = 1:results.Ntrigger;
results.Y_Nroi = 1:results.Nroi;
rows_Trigger = find(X_Trigger01);
flag_baseline = ( params.DFF_baselineXwin(1) <= results.X_ValMat )&( results.X_ValMat <= params.DFF_baselineXwin(2) );  

% > roi-loop
% roi_list = 1:FallMat.Nroi_orig;
% for roi_order = 1:FallMat.Nroi_orig
roi_list = FallMat.rois_ok;
for roi_order = 1:FallMat.Nroi_ok
    %%

    roi = roi_list(roi_order);
    results.roiids(roi_order,1) = roi;
    ValTrain = FallMat.(params.ValType)(roi,:); 
    SpksTrain = FallMat.spks(roi,:); 
    % > trigger-loop
    ValMat = ones( results.Ntrigger, length(results.X_ValMat) ) .* NaN;
    dFvalMat = ValMat;
    sgEx_01mat = ValMat;
    sgIn_01mat = ValMat;
    SpksMat = ValMat;
    for trigger = 1:results.Ntrigger 
        
        % > raw values
        S = rows_Trigger(trigger) - X_BinNum_MinusWin;
        E = rows_Trigger(trigger) + X_BinNum_PlusWin;
        if S <= 0        
            ValTrain_ThisTrigger = [ ones( 1, -S+1 ).*NaN, ValTrain(1:E) ]; 
            SpksTrain_ThisTrigger = [ ones( 1, -S+1 ).*NaN, SpksTrain(1:E) ]; 
            EventFile1D_ThisTrigger = [ ones( 1, -S+1 ).*NaN, EventFile1D(1:E) ]; 
        elseif Nbin < E
            ValTrain_ThisTrigger = [ ValTrain(S:Nbin), ones( 1, E-Nbin ).*NaN ];  
            SpksTrain_ThisTrigger = [ SpksTrain(S:Nbin), ones( 1, E-Nbin ).*NaN ];
            EventFile1D_ThisTrigger = [ EventFile1D(S:Nbin), ones( 1, E-Nbin ).*NaN ];
        elseif length(ValTrain) < S % error?
            ValTrain_ThisTrigger = ones( 1, length(S:E) ).*NaN;  
            SpksTrain_ThisTrigger = ones( 1, length(S:E) ).*NaN; 
            EventFile1D_ThisTrigger = ones( 1, length(S:E) ).*NaN; 
        else
            ValTrain_ThisTrigger = ValTrain(S:E);
            SpksTrain_ThisTrigger = SpksTrain(S:E);
            EventFile1D_ThisTrigger = EventFile1D(S:E);
        end
        ValMat(trigger,:) = ValTrain_ThisTrigger;
        SpksMat(trigger,:) = SpksTrain_ThisTrigger;
        EventMat(trigger,:) = EventFile1D_ThisTrigger;
        
        % > ΔF normarize
        Vals_baseline = ValTrain_ThisTrigger(flag_baseline==1);
        Val_baselineF0 = nanmedian(Vals_baseline);
        Spks_baseline = SpksTrain_ThisTrigger(flag_baseline==1);
        Spk_baselineF0 = nanmedian(Spks_baseline);
        switch params.DFFtype        
            case { '( F - F0 ) / median( abs( Fbase - F0 ) )' }
                dFvalTrain_ThisTrigger = ( ValTrain_ThisTrigger - Val_baselineF0 ) ./ nanmedian( abs( Vals_baseline - Val_baselineF0 ) );
                dSpksTrain_ThisTrigger = ( SpksTrain_ThisTrigger - Spk_baselineF0 ) ./ nanmedian( abs( Spks_baseline - Spk_baselineF0 ) );
            case { '( F - F0 ) / nanstd( Fbase - F0 )' }
                dFvalTrain_ThisTrigger = ( ValTrain_ThisTrigger - Val_baselineF0 ) ./ nanstd( Vals_baseline - Val_baselineF0 );
                dSpksTrain_ThisTrigger = ( SpksTrain_ThisTrigger - Spk_baselineF0 ) ./ nanstd( Spks_baseline - Spk_baselineF0 );
            case { '( F - F0 ) / F0' }
                dFvalTrain_ThisTrigger = ( ValTrain_ThisTrigger - Val_baselineF0 ) ./ Val_baselineF0;
                dSpksTrain_ThisTrigger = ( SpkTrain_ThisTrigger - Spk_baselineF0 ) ./ Spk_baselineF0;
        end
        dFvalMat(trigger,:) = dFvalTrain_ThisTrigger;
        dSpksMat(trigger,:) = dSpksTrain_ThisTrigger;
        % figure; plot(ValTrain_ThisTrigger); yyaxis right; plot(dFvalTrain_ThisTrigger);
        
        CANDS = find( getWinFlagX( results.X_ValMat, params.sg_targetXwin ) );
        window_targetXwin = [ CANDS(1) CANDS(end) ];

        % > stat
        train01 =  dFvalTrain_ThisTrigger > params.sg_ThrVal;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        data = train01; window = [ 1 length(data) ]; BorderValue = 0.1; % case 01
        SeqPoint = params.sg_SeqBinNum;
        [ border, counter, flag_state, borders ] = extractSeqArea( data, window, BorderValue, SeqPoint );
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        sgEx_01mat(trigger,:) = flag_state;

        train01 =  dFvalTrain_ThisTrigger < -params.sg_ThrVal;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        data = train01; window = [ 1 length(data) ]; BorderValue = 0.1; % case 01
        SeqPoint = params.sg_SeqBinNum;
        [ border, counter, flag_state, borders ] = extractSeqArea( data, window, BorderValue, SeqPoint );
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        sgIn_01mat(trigger,:) = flag_state;        
        
    end
    TargetMat = ValMat; [ ValMat_mean, ValMat_mean_smoothed, ValMat_sem_smoothed ] = binraster2psth_YTcopy( TargetMat, params.dt_frame, params.sigma_frame, { 1:size( TargetMat, 1 ) }, ones( size( TargetMat, 1 ), 1 ) ); % from cellBase
    TargetMat = SpksMat; [ SpksMat_mean, SpksMat_mean_smoothed, SpksMat_sem_smoothed ] = binraster2psth_YTcopy( TargetMat, params.dt_frame, params.sigma_frame, { 1:size( TargetMat, 1 ) }, ones( size( TargetMat, 1 ), 1 ) ); % from cellBase
    TargetMat = dFvalMat; [ dFvalMat_mean, dFvalMat_mean_smoothed, dFvalMat_sem_smoothed ] = binraster2psth_YTcopy( TargetMat, params.dt_frame, params.sigma_frame, { 1:size( TargetMat, 1 ) }, ones( size( TargetMat, 1 ), 1 ) ); % from cellBase
    TargetMat = dSpksMat; [ dSpksMat_mean, dSpksMat_mean_smoothed, dSpksMat_sem_smoothed ] = binraster2psth_YTcopy( TargetMat, params.dt_frame, params.sigma_frame, { 1:size( TargetMat, 1 ) }, ones( size( TargetMat, 1 ), 1 ) ); % from cellBase
    % figure; imagesc(results.sg_01mat);
    flag_OK = nansum(sgEx_01mat,2) > 0; sgEx_PerOK = ( nansum(flag_OK) / results.Ntrigger ) * 100;
    flag_OK = nansum(sgIn_01mat,2) > 0; sgIn_PerOK = ( nansum(flag_OK) / results.Ntrigger ) * 100;    
    % > set
    results.ValMatSet{roi_order,1} = ValMat; results.ValMat_ROIxTime_mean(roi_order,:) = ValMat_mean; results.ValMat_ROIxTime_mean_smoothed(roi_order,:) = ValMat_mean_smoothed; results.ValMat_ROIxTime_sem_smoothed(roi_order,:) = ValMat_sem_smoothed;
    results.SpksMatSet{roi_order,1} = SpksMat; results.SpksMat_ROIxTime_mean(roi_order,:) = SpksMat_mean; results.SpksMat_ROIxTime_mean_smoothed(roi_order,:) = SpksMat_mean_smoothed; results.SpksMat_ROIxTime_sem_smoothed(roi_order,:) = SpksMat_sem_smoothed;
    results.dFvalMatSet{roi_order,1} = dFvalMat; results.dFvalMat_ROIxTime_mean(roi_order,:) = dFvalMat_mean; results.dFvalMat_ROIxTime_mean_smoothed(roi_order,:) = dFvalMat_mean_smoothed; results.dFvalMat_ROIxTime_sem_smoothed(roi_order,:) = dFvalMat_sem_smoothed;
    results.dSpksMatSet{roi_order,1} = dSpksMat; results.dSpksMat_ROIxTime_mean(roi_order,:) = dSpksMat_mean; results.dSpksMat_ROIxTime_mean_smoothed(roi_order,:) = dSpksMat_mean_smoothed; results.dSpksMat_ROIxTime_sem_smoothed(roi_order,:) = dSpksMat_sem_smoothed;
    results.sgEx_01matSet{roi_order,1} = sgEx_01mat;
    results.sgEx_flag(roi_order,1) = sgEx_PerOK > params.sg_ThrPer;     
    results.sgIn_01matSet{roi_order,1} = sgIn_01mat;
    results.sgIn_flag(roi_order,1) = sgIn_PerOK > params.sg_ThrPer;    
    % > add
    results.dFvalMean_targetXwin(roi_order,1) = nanmean( reshape(dFvalMat(:,window_targetXwin), [], 1) );
    results.dFvalMedian_targetXwin(roi_order,1) = nanmedian( reshape(dFvalMat(:,window_targetXwin), [], 1) );  
    results.EventMatSet{roi_order,1} = EventMat;
    % figure; plot( results.X_ValMat, ValMat_mean_smoothed ); xlim(params.WindowSec);
    
end


results.sgEx_per = nansum(results.sgEx_flag) / FallMat.Nroi_ok * 100;
results.sgIn_per = nansum(results.sgIn_flag) / FallMat.Nroi_ok * 100;
results.params = params;


%% show


switch params.ShowType
        
    case 'ROIxTIME'
       %%
        
        ValLim = [ -1 2 ];
        figure(); FS = 12; LW = 2;
        
        subplot(2,1,1); hold on;
        imagesc( results.X_ValMat, results.Y_Nroi, results.dFvalMat_ROIxTime_mean);
        ylabel('#ROI');
        xlim(params.WindowSec); ylim( [ results.Y_Nroi(1)-.5 results.Y_Nroi(end)+.5 ] ); caxis(ValLim);
        yticks( [ results.Y_Nroi(1) results.Y_Nroi(end) ] );
        set( gca, 'FontSize', FS );
        
        subplot(2,1,2); cla; hold on;
        xline( 0, ':', 'LineWidth', LW ); yline( 0, ':', 'LineWidth', LW ); 
        plot( results.X_ValMat, results.dFvalMat_ROIxTime_mean_smoothed, 'LineWidth', LW );
%         [ val, idx ] = sort( mean( results.dFvalMat_ROIxTime_mean_smoothed, 2 ) );
%         figure; plot( results.X_ValMat, results.dFvalMat_ROIxTime_mean_smoothed( idx(end), : ), 'LineWidth', LW );
        xlim(params.WindowSec);
        xlabel( 'Time from trigger (sec)' ); ylabel( 'ΔF/F' );
        set( gca, 'box', 'off', 'FontSize', FS );
     
    %     X = results.X_ValMat;
    %     Y = 1:Nroi_ok;
    %     Dmat = ValMat;
    %     CAXIS = [ -1 1 ]; colorbar;
    %     YTimagesc( X, Y, Dmat,...
    %     'CM', 'fireice',...
    %     'CAXIS', CAXIS );
    %     xlabel( 'X' ); ylabel( 'Y' ); 
    %     set( gca, 'XTick', XTICK, 'YTick', YTICK, 'YDir', 'normal', 'TickDir', 'out', 'FontSize', FS, 'box', 'off' );
    %     set( cb, 'Ticks', [ cb.Ticks ], 'TickLength', 0, 'Location', 'eastoutside', 'FontSize', FS ); % 'TickLabels' { '-1 (Decrease)', '0', '1 (Increase)' }
    %     set( cb.Label, 'String', 'grad', 'Rotation', 270 ); % caxis( [ -1 1 ] );  

    
    case 'TRIALxTIME'
       %%
        
        if isempty(params.roi_target)
            id = randperm( results.Nroi, 1 );
        else
            id = find(results.roiids==params.roi_target);            
        end
        ValLim = [ -1 2 ];
        figure(); FS = 12; LW = 2;
        
        subplot(2,1,1); hold on;
        imagesc( results.X_ValMat, results.Y_Ntrigger, results.dFvalMatSet{id});
        ylabel('#Trial');
        xlim(params.WindowSec); ylim( [ results.Y_Ntrigger(1)-.5 results.Y_Ntrigger(end)+.5 ] ); caxis(ValLim);
        yticks( [ results.Y_Ntrigger(1) results.Y_Ntrigger(end) ] );
        title( [ 'Neuron ', num2str( results.roiids(id) ), ' : sg ', num2str( results.sgEx_flag(id) ) ] );
        set( gca, 'FontSize', FS );
        
        subplot(2,1,2); cla; hold on;
        xline( 0, ':', 'LineWidth', LW ); yline( 0, ':', 'LineWidth', LW );         
        plot( results.X_ValMat, results.dFvalMat_ROIxTime_mean_smoothed(id,:), 'LineWidth', LW  );
        xlim(params.WindowSec); ylim(ValLim);
        xlabel( 'Time from trigger (sec)' ); ylabel( 'ΔF/F' );
        set( gca, 'box', 'off', 'FontSize', FS );
%         title( [ num2str( size( COLtrialROWtimeSet{id}, 1 ) ), ' trials' ] );


    case 'TrialTraces'
       %%
        
        if isempty(params.roi_target)
            id = randperm( results.Nroi, 1 );
        else
            id = find(results.roiids==params.roi_target);            
        end
        figure(); FS = 12; LW = 2; range = 20;
        cla; hold on;
        xline( 0, ':', 'LineWidth', LW );
        for roi = 1:results.Nroi
            for trial = 1:results.Ntrigger
                base(1,trial) = range * trial;
                Y = results.dFvalMatSet{id}(trial,:) + base(1,trial);
                Y = smoothed_psth_YTcopy( Y, params.dt_frame, params.sigma_frame );
                
                plot( results.X_ValMat, Y, 'LineWidth', LW  );
            end
        end
        xlim(params.WindowSec); ylim( [ 0 base(end)+range ] );
        xlabel( 'Time from trigger (sec)' ); ylabel( '#Trial' );
%         yticks(base); yticklabels(1:results.Ntrigger);
        yticks([]);
        title( [ 'Neuron ', num2str( results.roiids(id) ), ' : sg ', num2str( results.sgEx_flag(id) ) ] );
        set( gca, 'FontSize', FS, 'box', 'off' );

        
    case 'TrialTracesTrain'
       %%
        
        figure(); FS = 12; LW = 2; range = 20;
        cla; hold on;  
        X_frame = 1:length(results.X_ValMat);
        Event01 = zeros( 1, length(results.X_ValMat) ); Event01(results.X_ValMat==0) = range/2;              
        for roi = 1:results.Nroi
            base(1,roi) = range * roi;  
            Xtrain = []; Ytrain = []; EventTrain = [];
            for trial = 1:results.Ntrigger
                Y = results.dFvalMatSet{roi}(trial,:);
                params.sigma_frame = 10;
                Y = smoothed_psth_YTcopy( Y, params.dt_frame, params.sigma_frame );
                Xtrain = [ Xtrain, X_frame + X_frame(end)*(trial-1) ];
                Ytrain = [ Ytrain, Y ];
                EventTrain = [ EventTrain, Event01 ];
            end
            plot( Xtrain, Ytrain + base(1,roi), 'LineWidth', LW  );
        end
        cols = find(EventTrain); for trial = 1:length(cols); xline( cols(trial), 'k:', 'LineWidth', LW ); end         
        plot( Xtrain, EventTrain, 'k', 'LineWidth', LW  );
        ylabel( '#ROI' ); yticks([]);
        set( gca, 'XColor', 'none', 'FontSize', FS, 'box', 'off' );
        
    
end


end
% >> 'Space'
function  Cimg = createSpaceMap( FallMat, params )
%% 

% params.rois_target = FallMat.rois_ok;
% params.Cvals = rand( 2, 1, length(params.rois_target) );
% params.Clim = [ 0 1 ];
% params.Cround = 1; % 1: 0.1
if isempty(params.Cvals)
    params.Cvals = rand( length(params.rois_target), 1 );
elseif length(params.Cvals)==1
     params.Cvals = ones( length(params.rois_target), 1 ) .* params.Cvals;
end


Cimg = zeros( FallMat.ops.Lx, FallMat.ops.Ly );
for idx = 1:length(params.rois_target)
    %%

    roi = params.rois_target(idx);
    Stat = FallMat.stat(roi);  
    xpix = Stat{1}.xpix;
    ypix = Stat{1}.ypix;

    %%% define color
    Cval = round( params.Cvals(idx), params.Cround );
    Cval( Cval < params.Clim(1) ) = params.Clim(1);
    Cval( params.Clim(2) < Cval ) = params.Clim(2);
%     switch params.Cround
%         case 1;  dt = 0.1;
%     end
%     Crange = round( params.Cround(1):dt:params.Cround(2), 1 );
%     Nbin = length(Crange);
%     FaceColors = YTcm( 'fireice', 'Nbin', Nbin, 'setgca', 'off' );  
%     RGB = FaceColors( Crange==Cval, : );
    %%%

    for ipx = 1:length(xpix)
%         Cimg( xpix(ipx)+1, ypix(ipx)+1 ) = Cval; % maybe, +1: 0~511?
        Cimg( ypix(ipx)+1, xpix(ipx)+1 ) = Cval; % maybe, +1: 0~511?, yx?
    end
    
end % figure; imagesc(Cimg);


end


% > (ref)
function results = calValMatAroundTrigger( ValTrain, X_ValTrain, X_Trigger, varargin )
%%


default_params = {
                   'WindowSec',     [ -5 5 ];...    
                   'TriggerLabel', "X_SmoothTouch";...
                   
%                    'dt',            0.03;... sec, "= BinSize", def: 0.03
                   'sigma',         0.1;... sec, def: 0.06                   
};
try params = parse_args_local( default_params, varargin{:} ); catch; params = parse_args_local( default_params, [] ); end


%%


Nx = length(X_ValTrain);
results.X_BinWidthMeanSec = nanmean( diff(X_ValTrain) ); % TE.X: full Xtrain ---> same value on each session!
X_BinNum_MinusWin = round( diff( [ params.WindowSec(1) 0 ] ) / results.X_BinWidthMeanSec );
X_BinNum_PlusWin = round( diff( [ 0 params.WindowSec(2) ] ) / results.X_BinWidthMeanSec );
results.X_ValMat = [ -X_BinNum_MinusWin:1:0, 1:1:X_BinNum_PlusWin ] * results.X_BinWidthMeanSec;
trials_valid = find( ~isnan(X_Trigger) );
results.Ntrials = length(trials_valid);
results.ValMat = ones( results.Ntrials, length(results.X_ValMat) );
for trial = 1:results.Ntrials
    row_LVMmat = find( X_ValTrain==X_Trigger( trials_valid(trial) ) );    
    S = row_LVMmat - X_BinNum_MinusWin;
    E = row_LVMmat + X_BinNum_PlusWin;
    if S < 0        
        results.ValMat(trial,:) = [ ones( -S+1, 1 ).*NaN; ValTrain(1:E) ]';        
    elseif Nx < E
        results.ValMat(trial,:) = [ ValTrain(S:Nx); ones( E-Nx, 1 ).*NaN  ]';       
    else
        results.ValMat(trial,:) = ValTrain(S:E);
    end
end
results.ValMat_mean = nanmean(results.ValMat);
results.ValMat_std = nanstd(results.ValMat);
results.ValMat_sem = nansem(results.ValMat);
results.params = params;


% ref: "getValidPsth"
binraster = results.ValMat;
COMPTRIALS = { 1:size( results.ValMat, 1 ) };
valid_trials = ones( size( results.ValMat, 1 ), 1 );
% dt = params.dt; % ref: "MHpv_plotLickInfo"
params.dt = results.X_BinWidthMeanSec;
[ ~, results.ValMat_mean_smoothed, results.ValMat_sem_smoothed ] = binraster2psth_YTcopy( binraster, params.dt, params.sigma, COMPTRIALS, valid_trials ); % from cellBase
% figure(1); plot( results.X_ValMat, results.ValMat_mean_smoothed );
results.memo_smoothed = "use binraster2psth_YTcopy";


end
function out = createTraceMat( Trace, StimTrainSet, params )
%%


% > define F0
out.RawTrace = Trace;
out.RawTrace_F0 = prctile( out.RawTrace, 35, 2 ); % figure; histogram(Trace); hold on; YLIM = ylim; plot( [ F0 F0 ], YLIM );
out.RawTrace_F0_memo = [ "ref: T Okada et al, Sci Adv (2021)";
"We used an F0 set at the 35th percentile of the total fluorescence distribution." ];
% out.RawTrace_F0 = prctile( out.RawTrace, 25, 2 );
% out.RawTrace_F0_memo = [ "We used an F0 set at the 25th percentile of the total fluorescence distribution." ];
% ref: CaImAn "extract_DF_F" ---> median(Trace) ??
out.RawTrace_SD = nanstd(out.RawTrace);
out.RawTrace_F0plusSD = out.RawTrace_F0 + out.RawTrace_SD;
out.Fborder_BASEplusSD = out.RawTrace_F0plusSD / out.RawTrace_F0; 
out.RawTrace_SD196 = out.RawTrace_SD * 1.96;
out.RawTrace_F0plusSD196 = out.RawTrace_F0 + out.RawTrace_SD196;
out.Fborder_BASEplusSD196 = out.RawTrace_F0plusSD196 / out.RawTrace_F0; 
out.RawTrace_75pertile = prctile( out.RawTrace, 75, 2 ); % non-normal distribution --> Interquartile range
out.Fborder_75pertile = out.RawTrace_75pertile / out.RawTrace_F0; 
out.RawTrace_80pertile = prctile( out.RawTrace, 80, 2 ); 
out.Fborder_80pertile = out.RawTrace_80pertile / out.RawTrace_F0; 
out.RawTrace_85pertile = prctile( out.RawTrace, 85, 2 ); 
out.Fborder_85pertile = out.RawTrace_85pertile / out.RawTrace_F0; 
out.RawTrace_90pertile = prctile( out.RawTrace, 90, 2 ); 
out.Fborder_90pertile = out.RawTrace_90pertile / out.RawTrace_F0;
out.RawTrace_95pertile = prctile( out.RawTrace, 95, 2 ); 
out.Fborder_95pertile = out.RawTrace_95pertile / out.RawTrace_F0; 


% > create "TraceMat"
Ntrials = length(StimTrainSet);
% figure; plot(Trace);
out.TraceMat_Raw = [];
out.TraceMat_Delta = [];
for trial = 1:Ntrials
%     XorderTrain = StimTrainSet(trial).XorderTrain;
    XorderStimTrigger = StimTrainSet(trial).XorderStimTrigger;    
    XorderStimDuration = StimTrainSet(trial).XorderStimDuration;
    ValidXorder = ( XorderStimTrigger + params.window(1) ):( XorderStimTrigger + params.window(2) );    
    Stim01Trace = ismember( ValidXorder, XorderStimDuration );    
    ValidRawTrace = out.RawTrace(ValidXorder);   
    out.TraceMat_Raw = [ out.TraceMat_Raw; ValidRawTrace ];
    ValidDeltaTrace = ValidRawTrace ./ out.RawTrace_F0;
    out.TraceMat_Delta = [ out.TraceMat_Delta; ValidDeltaTrace ];    
end
out.Stim01Trace = Stim01Trace;
OrderStimTrigger = find( ValidXorder==XorderStimTrigger );
out.AfterStim01Trace = out.Stim01Trace; out.AfterStim01Trace(OrderStimTrigger:end) = 1;
out.TraceMat_Raw_mean = nanmean(out.TraceMat_Raw);
out.TraceMat_Delta_mean = nanmean(out.TraceMat_Delta);
switch params.TraceType
    case { 'raw', 'Raw' }
        out.TraceMat = out.TraceMat_Raw;
        out.YLABEL = "Raw Ca^{2+} signal";
        BASE = out.RawTrace_F0;
    case 'DF/F'
        out.TraceMat = out.TraceMat_Delta; 
        out.YLABEL = "\Delta F/F";
        BASE = 1; % F0/F0
end
out.StimLength = length(XorderStimDuration);
out.X_TraceMat = params.window(1):params.window(2);
out.Y_TraceMat = 1:Ntrials;
% >> add
try
dataMat = out.TraceMat;
out.TraceMat_mean = nanmean(dataMat);
out.TraceMat_sh = nansem(dataMat); % SEM
% out.TraceMat_sh = nansem(dataMat)*1.96; % 2-SEM
out.TraceMat_2sd = nanstd(dataMat)*1.96; % 2-SD
catch
end


% > judge sensory or non-sensory neuron
Target01 = out.Stim01Trace; % StimOn~Off
Target01 = out.AfterStim01Trace; % StimOn~End
vals_forJudge = out.TraceMat_Delta_mean(Target01);
X_vals_forJudge = out.X_TraceMat(Target01);
switch params.BorderType
    case '1.96-SD'; out.Y_Border = out.Fborder_BASEplusSD196;
    case '1-SD'; out.Y_Border = out.Fborder_BASEplusSD;
    case '90-pertile'; out.Y_Border = out.Fborder_90pertile;
    case '85-pertile'; out.Y_Border = out.Fborder_85pertile;
    case '75-pertile'; out.Y_Border = out.Fborder_75pertile;
end
if sum( vals_forJudge > out.Y_Border ) > 1
    out.Label_responsivity = "responsive";
else
    out.Label_responsivity = "non-responsive";
end
% >> cal peak
out.Xorders_Stim1 = out.X_TraceMat(out.Stim01Trace==1);
[ val_max, order_max ] = max(vals_forJudge);
out.X_Peak = out.X_TraceMat(out.TraceMat_Delta_mean==val_max);
out.Y_Peak = val_max;
out.Y_Peak_Height = out.Y_Peak - 1;
% >>> extractSeqArea
% %% *****************************************************************
% data = [ 0 1 1 1 1 0 1 1 0 0 0 0 0 1 1 1 0 1 0 1 1 1 0 1 0 0 0 ];
% window = [ 1 length(data) ];
% BorderValue = 0.1; % case 01
% SeqPoint = 2;
% [ border, counter, flag_state, borders ] = extractSeqArea( data, window, BorderValue, SeqPoint );
% %% *****************************************************************
data = vals_forJudge;
window = [ 1 length(data) ];
BorderValue = out.Y_Border; 
SeqPoint = params.SeqPoint;
[ border, counter, flag_state, borders ] = extractSeqArea( data, window, BorderValue, SeqPoint );
X_Peak = out.X_Peak;
X_data = X_vals_forJudge;
out.X_Peak_WidthWin = [ NaN NaN ];
if sum( isnan(borders) )~=2
    for i = 1:size(borders,1)
        flag_exist = ( X_data( borders(i,1) ) <= X_Peak )&( X_Peak <= X_data( borders(i,2) ) );
        if flag_exist
            out.X_Peak_WidthWin = X_data( borders(i,:) );
            break;
        end
    end
end
out.X_Onset = out.X_Peak_WidthWin(1);
out.X_Offset = out.X_Peak_WidthWin(2);
out.X_Peak_Width = out.X_Peak_WidthWin(2) - out.X_Peak_WidthWin(1);


% % ref: "findpeak" function ... https://jp.mathworks.com/help/signal/ref/findpeaks.html
% % figure; findpeaks( out.TraceMat_mean, out.X_TraceMat, 'SortStr', 'descend', 'Annotate', 'extents' );
% [ pks, locs, widths, proms ] = findpeaks( out.TraceMat_mean, out.X_TraceMat, 'SortStr', 'descend', 'Annotate', 'extents' ); % , 'MinPeakProminence', 4
% if ~isempty(pks)
%     out.X_Peak = locs(1);
%     out.Y_Peak = pks(1);
%     out.Y_PeakMinusBase = out.Y_Peak - BASE;
%     out.X_PeakWidth = widths(1);
%     out.Y_PeakHeight = proms(1);
% else
%     out.X_Peak = NaN;
%     out.Y_Peak = NaN;
%     out.Y_PeakMinusBase = NaN;
%     out.X_PeakWidth = NaN;
%     out.Y_PeakHeight = NaN;    
% end
% out.memo_ShowPeaks = "figure; findpeaks( out.TraceMat_mean, out.X_TraceMat, 'Annotate', 'extents' );";


out.params = params;


end


%==========================================================================
% > lvm_import
function data = lvm_import(filename,verbose)
%LVM_IMPORT Imports data from a LabView LVM file
% DATA = LVM_IMPORT(FILENAME,VERBOSE) returns the data from a LVM (.lvm)
%  ASCII text file created by LabView.
%
% FILENAME    The name of the .lvm file, with or without ".lvm" extension
%
% VERBOSE     How many messages to display. Default is 1 (few messages),
%              0 = silent, 2 = display file information and all messages
%
% DATA        The data found in the LVM file. DATA is a structure with 
%              fields corresponding to the Segments in the file (see below) 
%              and LVM file header information.
%
%
% This function imports data from a text-formatted LabView Measurement File
%  (LVM, extension ".lvm") into MATLAB. A LVM file can have multiple
%  Segments, so that multiple measurements can be combined in a single
%  file. The output variable DATA is a structure with fields named
%  'Segment1', 'Segment2', etc. Each Segment field is a structure with
%  details about the data in the Segment and the actual data in the field
%  named 'data'. The column labels and units are stored as cell arrays that
%  correspond to the columns in the array of data.
% The size of the data array depends on the type of x-axis data that is
%  stored in the LVM file and the number of channels (num_channels).
%  There are three cases:
%  1) No x-data is included in the file ('No')
%   The data array will have num_channels columns (one column per channel
%   of data).
%  2) One column of x-data is included in the file ('One')
%   The first column of the data array will be the x-values, and the data
%   array will have num_channels+1 columns.
%  3) Each channel has its own x-data ('Multi')
%   Each channel has two columns, one for x-values, and one for data. The
%   data array will have num_channels*2 columns, with the x-values and
%   corresponding data in alternating columns. For example, in a Segment
%   with 4 channels, columns 1,3,5,7 will be the x-values for the data in
%   columns 2,4,6,8.
%
% Note: because MATLAB only works with a "." decimal separator, importing
%  large LVM files that use a "," (or other character) will be noticeably
%  slower. Use a "." decimal separator to avoid this issue.
%
% The LVM file specification is available at:
%   http://zone.ni.com/devzone/cda/tut/p/id/4139
%
%
% Example:
%
%  Use the following command to read in the data from a file containing two
%   Segments:
%
% >> d=lvm_import('testfile.lvm');
%
% Importing testfile.lvm:
%
% Import complete. 2 Segments found.
%
% >> d
% d = 
%       X_Columns: 'One'
%            user: 'hopcroft'
%     Description: 'Pressure, Flowrate, Heat, Power, Analog Voltage, Pump on, Temp'
%            date: '2008/03/26'
%            time: '12:18:02.156616'
%           clock: [2008 3 26 12 18 2.156616]
%        Segment1: [1x1 struct]
%        Segment2: [1x1 struct]
%
% >> d.Segment1
% ans = 
%            Notes: 'Some notes regarding this data set'
%     num_channels: 8
%          y_units: {8x1 cell}
%          x_units: {8x1 cell}
%               X0: [8x1 double]
%          Delta_X: [8x1 double]
%    column_labels: {9x1 cell}
%             data: [211x9 double]
%          Comment: 'This data rulz'
%
% >> d.Segment1.column_labels{2}
% ans =
% Thermocouple1
%
% >> plot(d.Segment1.data(:,1),d.Segment1.data(:,2));
% >> xlabel(d.Segment1.column_labels{1});
% >> ylabel(d.Segment1.column_labels{2});
%
%
%
% M.A. Hopcroft
%      < mhopeng at gmail.com >
%

% MH Sep2017
% v3.12 fix bug for importing data-only files
%		(thanks to Enrique Alvarez for bug reporting)
% MH Mar2017
% v3.1  use cellfun to vectorize processing of comma-delimited data
%       (thanks to Victor for suggestion)
% v3.0  use correct test for 'tab'
% MH Aug2016
% v3.0  (BETA) fixes for files that use comma as delimiter
%       improved robustness for files with missing columns
% MH Sep2013
% v2.2  fixes for case of comma separator in multi-segment files
%       use cell2mat for performance improvement
%       (thanks to <die-kenny@t-online.de> for bug report and testing)
% MH May2012
% v2.1  handle "no separator" bug
%       (thanks to <adnan.cheema@gmail.com> for bug report and testing)
%       code & comments cleanup
%       remove extraneous column labels (X_Value for "No X" files; Comment)
%       clean up verbose output
%       change some field names to NI names ("Delta_X","X_Columns","Date")
% MH Mar2012
% v2.0  fix "string bug" related to comma-separated decimals 
%       handle multiple Special Headers correctly
%       fix help comments
%       increment version number to match LabView LVM writer
% MH Sep2011
% v1.3  handles LVM Writer version 2.0 (files with decimal separator)
%       Note: if you want to work with older files with a non-"." decimal
%       separator character, change the value of "data.Decimal_Separator"
% MH Sep2010
% v1.2  bugfixes for "Special" header in LVM files.
%        (Thanks to <bobbyjoe23928@gmail.com> for suggestions)
% MH Apr2010
% v1.1  use case-insensitive comparisons to maintain compatibility with
%        NI LVM Writer version 1.00
%
% MH MAY2009
% v1.02 Add filename input
% MH SEP2008
% v1.01 Fix comments, add Cells
% v1.00 Handle all three possibilities for X-columns (No,One,Multi)
%       Handle LVM files with no header
% MH AUG2008
% v0.92 extracts Comment for each Segment
% MH APR2008
% v0.9  initial version
%

%#ok<*ASGLU>

% message level
if nargin < 2, verbose = 1; end % use 1 for release and 2 for BETA
if verbose >= 1, fprintf(1,'\nlvm_import v3.1\n'); end

% ask for filename if not provided already
if nargin < 1
    filename=input(' Enter the name of the .lvm file: ','s');
    fprintf(1,'\n');
end


%% Open the data file
% open and verify the file
fid=fopen(filename);
if fid ~= -1, % then file exists
    fclose(fid);
else
    filename=strcat(filename,'.lvm');
    fid=fopen(filename);
    if fid ~= -1, % then file exists
        fclose(fid);
    else
        error(['File not found in current directory! (' pwd ')']);
    end
end

% open the validated file
fid=fopen(filename);

if verbose >= 1, fprintf(1,' Importing "%s"\n\n',filename); end

% is it really a LVM file?
linein=fgetl(fid);
if verbose >= 2, fprintf(1,'%s\n',linein); end
% Some LabView routines create an LVM file with no header; just a text file
%  with columns of numbers. We can try to import this kind of data.
if isempty(strfind(linein,'LabVIEW'))
    try
        data.Segment1.data = dlmread(filename);
        if verbose >= 1, fprintf(1,'This file appears to be an LVM file with no header.\n'); end
        if verbose >= 1, fprintf(1,'Data was copied, but no other information is available.\n'); end
        return
    catch fileEx
        error('This does not appear to be a text-format LVM file (no recognizeable header or data).');
    end
end


%% Process file header
% The file header contains several fields with useful information

% default values
data.Decimal_Separator = '.';
text_delimiter={',',' ','\t'};
data.X_Columns='One';

% File header contains date, time, etc.
% Also the file delimiter and decimal separator (LVM v2.0)
if verbose >= 2, fprintf(1,' File Header Contents:\n\n'); end
while 1 
    
    % get a line from the file
    linein=fgetl(fid);
    % handle spurious carriage returns
    if isempty(linein), linein=fgetl(fid); end
    if verbose >= 3, fprintf(1,'%s\n',linein); end
    % what is the tag for this line?
    t_in = textscan(linein,'%s','Delimiter',text_delimiter);
    if isempty(t_in{1}{1})
        tag='notag';
    else
        tag = t_in{1}{1};
    end
    % exit when we reach the end of the header
    if strfind(tag,'***End_of_Header***')
        if verbose >= 2, fprintf(1,'\n'); end
        break
    end
    
    % get the value corresponding to the tag
%     if ~strcmp(tag,'notag')
%         v_in = textscan(linein,'%*s %s','delimiter','\t','whitespace','','MultipleDelimsAsOne', 1);
        if size(t_in{1},1)>1 % only process a tag if it has a value
%             val = v_in{1}{1};
            val = t_in{1}{2};
    
            switch tag
                case 'Date'
                    data.Date = val;
                case 'Time'
                    data.Time = val;
                case 'Operator'
                    data.user = val;
                case 'Description'
                    data.Description = val;
                case 'Project'
                    data.Project = val;            
                case 'Separator'
                    % v3 separator sanity check
                    if strcmpi(val,'Tab')
                        text_delimiter='\t';
                        if strfind(linein,',')
                            fprintf(1,'ERROR: File header reports "Tab" but uses ",". Check the file and correct if necessary.\n');
                            return
                        end
                    elseif strcmpi(val,'Comma') || strcmpi(val,',')
                        text_delimiter=',';
                        if strfind(linein,sprintf('\t'))
                            fprintf(1,'ERROR: File header reports "Comma" but uses "tab". Check the file and correct if necessary.\n');
                            return
                        end
                    end
                    
                case 'X_Columns'
                    data.X_Columns = val;
                case 'Decimal_Separator'
                    data.Decimal_Separator = val;
            end
            if verbose >= 2, fprintf(1,'%s: %s\n',tag,val); end
        end
%     end    
    
end

% create matlab-formatted date vector
if isfield(data,'time') && isfield(data,'date')
    dt = textscan(data.Date,'%d','Delimiter','/');
    tm = textscan(data.Time,'%d','Delimiter',':');
    if length(tm{1})==3
        data.clock=[dt{1}(1) dt{1}(2) dt{1}(3) tm{1}(1) tm{1}(2) tm{1}(3)];
    elseif length(tm{1})==2
        data.clock=[dt{1}(1) dt{1}(2) dt{1}(3) tm{1}(1) tm{1}(2) 0];
    else
        data.clock=[dt{1}(1) dt{1}(2) dt{1}(3) 0 0 0];
    end
end

if verbose >= 3, fprintf(1,' Text delimiter is "%s":\n\n',text_delimiter); end


%% Process segments
% process data segments in a loop until finished
segnum = 1;
val=[]; tag=[]; %#ok<NASGU>
while 1
    %segnum = segnum +1;
    fieldnm = ['Segment' num2str(segnum)];

    %% - Segment header
    if verbose >= 1, fprintf(1,' Segment %d:\n\n',segnum); end
    % loop to read segment header
    while 1
        % get a line from the file
        linein=fgetl(fid);
        % handle spurious carriage returns/blank lines/end of file
        while isempty(linein), linein=fgetl(fid); end
        if feof(fid), break; end
        if verbose >= 3, fprintf(1,'%s\n',linein); end
        
        % Ignore "special segments"
        % "special segments" can hold other types of data. The type tag is
        % the first line after the Start tag. As of version 2.0,
        % LabView defines three types:
        %  Binary_Data
        %  Packet_Notes
        %  Wfm_Sclr_Meas
        % In theory, users can define their own types as well. LVM_IMPORT
        %  ignores any "special segments" it finds.
        % If special segments are handled in future versions, recommend
        %  moving the handler outside the segment read loop.
        if strfind(linein,'***Start_Special***')            
            special_seg = 1;
            while special_seg                

                while 1 % process lines until we find the end of the special segment 
                    % get a line from the file
                    linein=fgetl(fid);
                    % handle spurious carriage returns
                    if isempty(linein), linein=fgetl(fid); end
                    % test for end of file
                    if linein==-1, break; end
                    if verbose >= 2, fprintf(1,'%s\n',linein); end
                    if strfind(linein,'***End_Special***')
                        if verbose >= 2, fprintf(1,'\n'); end
                        break
                    end
                end
                
                % get the next line and proceed with file 
                %  (there may be additional Special Segments)
                linein=fgetl(fid);
                % handle spurious carriage returns/blank lines/end of file
                while isempty(linein), linein=fgetl(fid); end
                if feof(fid), break; end
                if isempty(strfind(linein,'***Start_Special***'))
                    special_seg = 0;
                    if verbose >= 1, fprintf(1,' [Special Segment ignored]\n\n'); end
                end
            end
        end % end special segment handler
        
        
        % what is the tag for this line?
        t_in = textscan(linein,'%s','Delimiter',text_delimiter);
        if isempty(t_in{1}{1})
            tag='notag';
        else
            tag = t_in{1}{1};
            %disp(t_in{1})
        end
        if verbose >= 3, fprintf(1,'%s\n',linein); end
        % exit when we reach the end of the header
        if strfind(tag,'***End_of_Header***')
            if verbose >= 3, fprintf(1,'\n'); end
            break
        end
        
        % get the value corresponding to the tag
        % v3 assignments use dynamic field names
        if size(t_in{1},1)>1 % only process a tag if it has a value
            switch tag
                case 'Notes'
    %                 %d_in = textscan(linein,'%*s %s','delimiter','\t','whitespace','');
    %                 d_in = linein;
                    data.(fieldnm).Notes = t_in{1}{2:end};
                case 'Test_Name'
    %                 %d_in = textscan(linein,'%*s %s','delimiter','\t','whitespace','');
    %                 d_in = linein;
                    data.(fieldnm).Test_Name = t_in{1}{2:end};  %d_in{1}{1};           
                case 'Channels'
    %                 numchan = textscan(linein,sprintf('%%*s%s%%d',text_delimiter),1)
    %                 data.(fieldnm).num_channels = numchan{1};
                    data.(fieldnm).num_channels = str2num(t_in{1}{2});
                case 'Samples'
    %                 numsamp = textscan(linein,'%s','delimiter',text_delimiter);
    %                 numsamp1 = numsamp{1};
                    numsamp1 = t_in{1}(2:end);
    %                 numsamp1(1)=[]; % remove tag "Samples"
                    num_samples=[];
                    for k=1:length(numsamp1)
                        num_samples = [num_samples sscanf(numsamp1{k},'%f')]; %#ok<AGROW>
                    end
                    %numsamp2=str2num(cell2mat(numsamp1));                              %#ok<ST2NM>
                    data.(fieldnm).num_samples = num_samples;                
                case 'Y_Unit_Label'
    %                 Y_units = textscan(linein,'%s','delimiter',text_delimiter);
    %                 data.(fieldnm).y_units=Y_units{1}';
                    data.(fieldnm).y_units=t_in{1}';
                    data.(fieldnm).y_units(1)=[]; % remove tag
                case 'Y_Dimension'
    %                 Y_Dim = textscan(linein,'%s','delimiter',text_delimiter);
    %                 data.(fieldnm).y_type=Y_Dim{1}';
                    data.(fieldnm).y_type=t_in{1}';
                    data.(fieldnm).y_type(1)=[]; % remove tag
                case 'X_Unit_Label'
    %                 X_units = textscan(linein,'%s','delimiter',text_delimiter);
    %                 data.(fieldnm).x_units=X_units{1}';
                    data.(fieldnm).x_units=t_in{1}';
                    data.(fieldnm).x_units(1)=[];
                case 'X_Dimension'
    %                 X_Dim = textscan(linein,'%s','delimiter',text_delimiter);
    %                 data.(fieldnm).x_type=X_Dim{1}';
                    data.(fieldnm).x_type=t_in{1}';
                    data.(fieldnm).x_type(1)=[]; % remove tag
                case 'X0'           
                    %[Xnought, val]=strtok(linein);
                    val=t_in{1}(2:end);
                    if ~strcmp(data.Decimal_Separator,'.')
                        val = strrep(val,data.Decimal_Separator,'.');
                    end
                    X0=[];
                    for k=1:length(val)
                        X0 = [X0 sscanf(val{k},'%e')]; %#ok<AGROW>
                    end
                    data.(fieldnm).X0 = X0;
                    %data.(fieldnm).X0 = textscan(val,'%e');
                case 'Delta_X' %,
                    %[Delta_X, val]=strtok(linein);
                    val=t_in{1}(2:end);
                    if ~strcmp(data.Decimal_Separator,'.')
                        val = strrep(val,data.Decimal_Separator,'.');
                    end
                    Delta_X=[];
                    for k=1:length(val)
                        Delta_X = [Delta_X sscanf(val{k},'%e')]; %#ok<AGROW>
                    end
                    data.(fieldnm).Delta_X = Delta_X;                
            end
        end
        
    end % end reading segment header loop
    % Done reading segment header
    
    % after each segment header is the row of column labels
    linein=fgetl(fid);
    Y_labels = textscan(linein,'%s','delimiter',text_delimiter);       
    data.(fieldnm).column_labels=Y_labels{1}';
    % The X-column always exists, even if it is empty. Remove if not used.
    if strcmpi(data.X_Columns,'No')
        data.(fieldnm).column_labels(1)=[];
    end
    % remove empty entries and "Comment" label
    if any(strcmpi(data.(fieldnm).column_labels,'Comment'))
        data.(fieldnm).column_labels=data.(fieldnm).column_labels(1:find(strcmpi(data.(fieldnm).column_labels,'Comment'))-1);
    end
    % display column labels
    if verbose >= 1
        fprintf(1,' %d Data Columns:\n | ',length(data.(fieldnm).column_labels));
        for i=1:length(data.(fieldnm).column_labels)
            fprintf(1,'%s | ',data.(fieldnm).column_labels{i});
        end
        fprintf(1,'\n\n');
    end



    %% - Segment Data
    % Create a format string for textscan depending on the number/type of
    %  channels. If there are additional segments, texscan will quit when
    %  it comes to a text line which does not fit the format, and the loop
    %  will repeat.
    if verbose >= 1, fprintf(1,' Importing data from Segment %d...',segnum); end
    
    % How many data columns do we have? (including X data)
    switch data.X_Columns
        case 'No'
            % an empty X column exists in the file
            numdatacols = data.(fieldnm).num_channels+1;
            xColPlural='no X-Columns';
        case 'One'
            numdatacols = data.(fieldnm).num_channels+1;
            xColPlural='one X-Column';
        case 'Multi'
            numdatacols = data.(fieldnm).num_channels*2;
            xColPlural='multiple X-Columns';
    end
    
    % handle case of not using periods (aka "dot" or ".") for decimal point separators
    %  (LVM version 2.0+)
    if ~strcmp(data.Decimal_Separator,'.')
        if verbose >= 2, fprintf(1,'\n  (using decimal separator "%s")\n',data.Decimal_Separator); end
        
        % create a format string for reading data as numbers
        fs = '%s'; for i=2:numdatacols, fs = [fs ' %s']; end                %#ok<AGROW>
        % add one more column for the comment field
        fs = [fs ' %s'];                                                   %#ok<AGROW>
        % v3.1 - use cellfun to process data
        % Read columns as strings 
        rawdata = textscan(fid,fs,'delimiter',text_delimiter); 
        % Convert ',' decimal separator to '.' decimal separator 
        rawdata = cellfun(@(x) strrep(x,data.Decimal_Separator,'.'), rawdata, 'UniformOutput', false);
		% save first row comment as The Comment for this segment
        data.(fieldnm).Comment = rawdata{size(rawdata,2)}{1};		
        % Transform strings back to numbers 
        rawdata = cellfun(@(x) str2double(x), rawdata, 'UniformOutput', false);
    
    % else is the typical case, with a '.' decimal separator
    else
        % create a format string for reading data as numbers
        fs = '%f'; for i=2:numdatacols, fs = [fs ' %f']; end                    %#ok<AGROW>
        % add one more column for the comment field
        fs = [fs ' %s'];                                                        %#ok<AGROW>
        % read the data from file
        rawdata = textscan(fid,fs,'delimiter',text_delimiter);
        % save first row comment as The Comment for this segment
        data.(fieldnm).Comment = rawdata{size(rawdata,2)}{1};
    end
    
    % v2.2 use cell2mat here instead of a loop for better performance
    % consolidate data into a simple array, ignore comments
    data.(fieldnm).data=cell2mat(rawdata(:,1:numdatacols));
    
    % If we have a "No X data" file, remove the first column (it is empty/NaN)
    if strcmpi(data.X_Columns,'No')
        data.(fieldnm).data=data.(fieldnm).data(:,2:end);
    end
    
    if verbose >= 1, fprintf(1,' complete (%g data points (rows)).\n\n',length(data.(fieldnm).data)); end
    
    % test for end of file
    if feof(fid)
        if verbose >= 2, fprintf(1,' [End of File]\n\n'); end
        break;
    else
        segnum = segnum+1;
    end    
    
    
end % end process segment


if verbose >= 1
    if segnum > 1, segplural='Segments';
    else segplural='Segment'; end
    fprintf(1,'\n Import complete. File has %s and %d Data %s.\n\n',xColPlural,segnum,segplural);
end


% close the file
fclose(fid);
return


end
% > https://github.com/yu-lab-vt/AQuA
function [ img, maxVal ] = readTiffSeq( fName, rescaleImg )
%%


%READTIFF Read image sequence

if ~exist('rescaleImg','var')
    rescaleImg = 0;
end

info = imfinfo(fName);
maxVal = 2^info(1).BitDepth-1;
nFrames = numel(info);
oneFrame = imread(fName, 1);
% change
H = info(1).Height;
W = info(1).Width;
if(numel(info)>1)
    nChannel = info(1).SamplesPerPixel;
    % [nRow,nCol] = size(oneFrame);
    img = zeros(H, W, nFrames, 'single');
    for k = 1:nFrames
        oneFrame = imread(fName, k);
        if(nChannel>1)
            oneFrame = mean(oneFrame,3);
        end
        if rescaleImg
            img(:,:,k) = single(oneFrame)/maxVal;
        else
            img(:,:,k) = oneFrame;
        end
    end
else
    T = floor(info.FileSize/info.StripByteCounts);
    img = zeros(H, W, T, 'single');
    start_point = info.StripOffsets(1) + (0:1:(T-1)).*info.StripByteCounts;
    fID = fopen (fName, 'r');
    for k = 1:T
        fseek (fID, start_point(k), 'bof');
        if info.BitDepth==32
            A = fread(fID, [H W], 'uint32=>uint32');
        elseif info.BitDepth==16
            A = fread(fID, [H W], 'uint16=>uint16');
        else
            A = fread(fID, [H W], 'uint8=>uint8');
        end
        
        img(:,:,k) = A';
    end
    fclose(fID);
end


end


%==========================================================================
% >> extra
% usage >>> try params = parse_args_local( default_params, varargin{:} ); V = params.V; catch; params = parse_args_local( default_params, [] ); end
function params = parse_args_local( default_params, varargin )
%%


d = default_params'; % flip matrix
% for id = 1:length(d)
%     if size( d{2,id} )
%         d{2,id} = { d{2,id} }; % in cell
%     end
% end
default_args = struct(d{:});


if ( length(varargin)==1 )&&( isempty( varargin{1} ) ) % usage ... parse_args_local = parse_args_local(default_params,[]); 
    
    params = default_args;
    
else
    
    for i = 1:length(varargin) % cell filter, {{}} or {}
        if iscell( varargin{i} )&&( length(varargin{i})~=1 ); varargin(i) = { varargin(i) }; end
    end

    manual_args = struct(varargin{:});
    m_fields = fieldnames(manual_args);
    d_fields = fieldnames(default_args);
    toset_fields = setdiff(d_fields,m_fields);
    for iF = 1:length(toset_fields)
        manual_args.(toset_fields{iF}) = default_args.(toset_fields{iF});
    end
    params = manual_args;
    
end


end
function nowfor(varargin) % <<< "nowfor" @YTprograms
%%

switch nargin
    case 2
       i = varargin{1};
       Li = varargin{2};  
       TEXT = [ num2str(i), '/', num2str(Li) ];
    case 3
       i = varargin{1};
       Li = varargin{2}; 
       Char = varargin{3};       
       TEXT = [ Char, num2str(i), '/', num2str(Li) ];        
end

disp(TEXT);


end
function [ SEM, STD, N, CI ] = nansem( inX, varargin ) % <<< "nansem" @YTprograms
%%


default_params = {
                   'dim', 1;... 
};
params = parse_args_local( default_params, varargin{:} );


%%


STD = nanstd( inX, 0, params.dim ); % [ input, flag, dim ]
SEM = ones( size(STD) ).*NaN;
CI = ones( size(STD) ).*NaN;
L = length(STD);
if isempty(inX)==1; N = 0; return; end 


for i = 1:L 
    X = inX( :, i );
    N = sum( isnan( X )==0 );
    if N~=0
       SEM(i) = STD(i) / sqrt(N);
    end
end


CI = SEM *1.96; % 95%CI = SE x 1.96


end
function params = ShadowPlot( X, Y, Sh, varargin ) % <<< "YTshadowplot" @YTprograms
%% load 


default_params = {
                   'Color',        [ 0 0 0 ];...
                   'ShadowColor',  [ 0.7843  0.7843  0.7961 ];...
                   'ShadowAlpha',  1;...   
                   'LineWidth',    1.5;...
                   'LineForm',     '-';...                   
                   'insert0',      'off';... NaN >>> 0
                   
                   'Ylimit', [];
};
params = parse_args_local(default_params,varargin{:});


if nargin==2
    Sh = Y;
    Y = X;
    X = 1:length(Y);
end


% NaN filter
NaNflag_X = isnan(X);
NaNflag_Y = isnan(Y);
if ( sum( NaNflag_X )>0 )||( sum( NaNflag_Y )>0 )
    if sum( NaNflag_X )>( sum( NaNflag_Y )>0 )
        NaNflag = NaNflag_X;
    else
        NaNflag = NaNflag_Y;
    end
    if strcmp(params.insert0,'on')
        Y( NaNflag ) = 0;
        Sh( NaNflag ) = 0;
    else
        X( NaNflag ) = [];
        Y( NaNflag ) = [];
        Sh( NaNflag ) = [];        
    end
end


%% show


% disp shadederrorbar
Ytop = Y + Sh;
Ybottom = Y - Sh;
pY = [ Ytop, fliplr(Ybottom) ];
pX = [ X, fliplr(X) ];
if ~isempty(params.Ylimit)
    pY( pY<=params.Ylimit(1) ) = params.Ylimit(1);
    pY( pY>=params.Ylimit(2) ) = params.Ylimit(2);
end
params.SHADOW = patch( pX, pY, params.ShadowColor, 'FaceAlpha', params.ShadowAlpha, 'EdgeColor', 'none' ); hold on;


% disp line
params.LINE = plot( X, Y, params.LineForm, 'color', params.Color, 'LineWidth', params.LineWidth ); 


end
function [ sortedMat, orderMax, valMax_sort, idxMax_sort, valMin_sort, idxMin_sort ] = sortMat( targetMat, varargin ) % <<< "sortMat" @YTprograms
%% load

default_params = {
                   'format', 'Max';... 'Max', 'MaxMin' 
                   'flag_valid', [];...
};
params = parse_args_local(default_params,varargin{:});

row = size(targetMat,1);
col = size(targetMat,2);
targetMat_original = targetMat;
if ~isempty(params.flag_valid)
    targetMat( :, params.flag_valid==0 ) = NaN;
end


%%

switch params.format
    
    
    case 'Max'
        %%
        
        [ vMax, idxMax ] = max(targetMat');
        [ idxMax_sort, orderMax ] = sort(idxMax);
        valMax_sort = vMax(orderMax);
        sortedMat = targetMat_original(orderMax,:);
        % > add min
        [ vMin, idxMin ] = min(targetMat');
        valMin_sort = vMin(orderMax);
        idxMin_sort = idxMin(orderMax);
        
        
    case 'MaxMin' % -1~0~1
        %%
        
        [ vMax_abs, idxMax_abs ] = max( abs(targetMat)' );
        for i = 1:length(idxMax_abs)
            vMax_pm(i) = targetMat( i, idxMax_abs(i) );
        end     
        [ val, order_p ] = sort( idxMax_abs(vMax_pm>=0), 'ascend' );
        [ val, order_m ] = sort( idxMax_abs(vMax_pm<0), 'descend' ); 
        targetMat_p = targetMat_original( vMax_pm>=0, : );
        targetMat_m = targetMat_original( vMax_pm<0, : );
        sortedMat = [ targetMat_m(order_m,:); targetMat_p(order_p,:) ];
        rows_p = find(vMax_pm>=0);
        rows_m = find(vMax_pm<0);
        orderMax = [ rows_m(order_m), rows_p(order_p) ];
        valMax_sort = [];
        idxMax_sort = [];
        valMin_sort = [];
        idxMin_sort = [];
        
        
end


end
function [psth, spsth, spsth_se] = binraster2psth_YTcopy(binraster,dt,sigma,COMP,valid_trials) 
%%
%BINRASTER2PSTH    PSTH from binned spike raster.
%   [PSTH, SPSTH, SPSTH_SE] = BINRASTER2PSTH(BINRASTER,DT,SIGMA,COMP,VALID_TRIALS)
%   calculates PSTH, smoothed PSTH (SPSTH) and standard error of smoothed
%   PSTH (SPSTH_SE) from BINRASTER at time resolution DT. The output is
%   restricted to VALID_TRIALS (1 x NUM_TRIALS). COMP: M x NUM_TRIALS
%   matrix of integers (0...N_CONDITION), the matrix for partitioning
%   trials. SIGMA determines the smoothing kernel for the smoothed PSTH
%   (see SMOOTHED_PSTH).
%
%   See also SMOOTHED_PSTH, STIMES2BINRASTER and VIEWCELL2B.

%   Edit log: AK 06/1, AK 07/1, BH 6/23/11, 7/5/12

% If valid_trials doesn't contain trial number then convert
if isbinary(valid_trials) 
     valid_trials = find(valid_trials);
end

% Calculate positions
if iscell(COMP)
    nCOND = length(COMP);
    positions = cell(1,nCOND);
    for i = 1:nCOND
        positions{i} = intersect(COMP{i},valid_trials);
    end  % i
else   % matrix
    iCOND = 1;
    nCOND = size(COMP,1);
    for i = 1:nCOND
        CONDITIONS = unique(COMP(i,:));
        if length(CONDITIONS) > 2 && ~ismember(100,CONDITIONS)
            CONDITIONS = setdiff(CONDITIONS,0);   % conditions to compare, 0 doesn't count
        end
        for j = 1:length(CONDITIONS)
            positions{iCOND} = intersect(find(COMP(i,:)==CONDITIONS(j)),valid_trials); %#ok<AGROW>
            iCOND = iCOND + 1;
        end   % j
    end   % i
end    % if

% Preallocate output
psth = nan(nCOND,size(binraster,2));
psth_sd = psth;
spsth = psth;
spsth_se = psth;

% Calculate PSTH
for iCOND = 1:length(positions)
    NUM_TRIALS = length(positions{iCOND});  % doesn't account for variable windows
    if ~isempty(positions{iCOND})  
        psth(iCOND,:) = nanmean(binraster(positions{iCOND},:)) / dt; 
        psth_sd(iCOND,:) = nanstd(binraster(positions{iCOND},:)) / dt;
        spsth(iCOND,:) = smoothed_psth_YTcopy(psth(iCOND,:),dt,sigma);
        spsth_se(iCOND,:) = smoothed_psth_YTcopy(psth_sd(iCOND,:) ./ sqrt(NUM_TRIALS-1),dt,sigma);
    end
end   % iCOND


end
function [spsth, conv_psth] = smoothed_psth_YTcopy(psth,dt,sigma) % = smoothed_psth in cellbase % 180622
%%
%SMOOTHED_PSTH   Smoothed PSTH.
%   [SPSTH, CONV_PSTH] = SMOOTHED_PSTH(PSTH,DT,SIGMA) calculates smoothed
%   PSTH (SPSTH) from PSTH at time resolution DT. SIGMA determines the
%   smoothing Kernel (3*SIGMA wide). Filtered PSTH without normalization is
%   returned in CONV_PSTH.
%
%   See also BINRASTER2PSTH.

%   Edit log: BH 6/23/11

% Make smoothed PSTH
if sigma > 0
    kernel_time = -3*sigma:dt:3*sigma;      % 3 sigma wide
    kernel = normpdf(kernel_time,0,sigma);       % define smoothing kernel
    conv_psth = conv(psth,kernel);               % convolve filter and psth
    
    steps = length(kernel);                     % the next 4 lines make sure to clip the ends of the convolved array correctly.
    first = floor(steps/2) + mod(steps,2);        % there is an issue with rounding if dt is too close to sigma
    last = length(conv_psth) - floor(steps/2);
    spsth = conv_psth(first:last);              
    
    spsth = spsth / sum(kernel);  % normalize by kernel area and dt
else
    spsth = psth;
    conv_psth = psth;
end
end
function TrueFalse = isbinary(x)
%%
%ISBINARY   Determine whether an array is binary.
%   TF = ISBINARY(X) returns 1 if X consists of 0 and 1 values, and 0 
%   otherwise.
%
%   See also DEC2BIN and BIN2DEC.

%   Edit log: BH 1/28/13

% Determine whether the input is binary
TrueFalse =  isempty(setdiff(unique(x),[0 1]));


end
function [ border, counter, flag_state, borders ] = extractSeqArea( data, window, BorderValue, SeqPoint ) % <<< "seqArea" @YTprograms
%%


flag_disp = 0;
flag_allNaN = 0;
borders_start = [];
borders_end = []; 
startT = window(1);
endT = window(2);
t = startT;
while t < endT
    
    flag_start = 0;
    counter_start = 0;
    counter_end = 0;
    
    for t2 = t:endT

        rate = data( t2 );

        % border_start ( use rate )
        if ( flag_start==0 )&&( rate >= BorderValue )&&( isnan( rate )==0 )
            counter_start = counter_start + 1;
        else
            counter_start = 0;
        end
        if counter_start==SeqPoint
            flag_start = 1; % start
            border_start = t2 - SeqPoint + 1; % e.g. 100 101 102 --> 102 - 3 + 1 = 100
            borders_start = [ borders_start; border_start ];
        end
        if ( flag_start==0 )&&( t2==endT )
            t = t2;
            break;
        end        

        % border_end ( use rate ) 
        if ( flag_start==1 )&&( rate < BorderValue ) 
            counter_end = counter_end + 1;
        elseif ( flag_start==1 )&&( rate >= BorderValue )
            counter_end = 0;
        end
        if counter_end == SeqPoint
            border_end = t2 - SeqPoint; % e.g. 200 201 202 --> 202 - 3 = 199
            borders_end = [ borders_end; border_end ];
            t = t2;
            flag_start = 0;
            break;
        end
        if ( flag_start==1 )&&( t2==endT )
            borders_end = [ borders_end; endT ];
            t = t2;
            flag_start = 0;
            break;
        end
        
    end % end t2
    
    if ( t > 10000 )&&( t2 > 10000 )
        error( 'while error' );
    end
end % while
if ( isempty( borders_start )==1 )||( isempty( borders_end )==1 ) 
    borders_start = NaN;
    borders_end = NaN;
    flag_allNaN = 1;
end


% outputs
if flag_allNaN==0
    % all parts ( for criterion )
    flag_state = zeros( size( data ) );
    border = [ borders_start(1), borders_end(end) ];
    borders = [ borders_start, borders_end ]; 
    for i = 1:size( borders, 1 )
        flag_state( borders( i, 1 ):borders( i, 2 ) ) = 1;
        counter = sum( flag_state );
    end
    % only first
    flag_state_first = zeros( size( data ) );
    border_first = [ borders_start(1), borders_end(1) ];
    flag_state_first( border_first(1):border_first(2) ) = 1;
    counter_first = sum( flag_state_first );
else
    % all parts ( for criterion )
    flag_state = zeros( size( data ) );
    border = [ NaN, NaN ];
    borders = [ NaN, NaN ]; 
    counter = 0;
    % only first 
    flag_state_first = zeros( size( data ) );
    border_first = [ NaN, NaN ];
    counter_first = 0;
end


if flag_disp==1
    figure;
    plot( data ); hold on;
    plot( find( flag_state ), ones( sum( flag_state==1 ), 1 ).*BorderValue, 'o' ); hold on;
    plot( [ border(1), border(1) ], ylim ); hold on;  
    plot( [ border(2), border(2) ], ylim ); hold on;    
    plot( xlim, [ BorderValue, BorderValue ] ); hold on;
elseif flag_disp==2
    figure;
    plot( data ); hold on;
    plot( find( flag_state_first ), ones( sum( flag_state_first==1 ), 1 ).*BorderValue, 'o' ); hold on;
    plot( [ border_first(1), border_first(1) ], ylim ); hold on;  
    plot( [ border_first(2), border_first(2) ], ylim ); hold on;    
    plot( xlim, [ BorderValue, BorderValue ] ); hold on;
end



end
function saveFig( flag_save, TITLE )
%%


% flag_save = 1;
try
if flag_save==1
exportPlace = desktop;
fig = gcf; figTitle = TITLE; filename = fullfile( exportPlace, figTitle );
print( fig, '-painters', '-r450', [ filename, '.jpg' ], '-djpeg' );
% close(fig);
end
catch
end


end


%==========================================================================
function WORKSPACE
%% usage: loadFallMatFile, createEventFile --> evalFallMatFile( FallMat, 'EventFile', EF.EventFile1D )


% > load Fall.mat
cd('G:'); [ FallMat, ROIinfoTable ] = loadFallMatFile( 'thr_prob_iscell', 0.5 );
% > load EventFile1D
EF = createEventFile( 'FrameMax', FallMat.Nframe );
% > eval Fall.mat
FrameHz = 2; sigma_frame = 2; WindowSec = [ -10 10 ];
FrameHz = 30; sigma_frame = 10; WindowSec = [ -10 10 ];
EventFileLabel = "EventFile1D_FrameBase_StimOnset"; % figure; bar( EF.(EventFileLabel) ); title( sum( EF.(EventFileLabel) ) );
EventFileLabel = "EventFile1D_FrameBase_RewardOnset"; % figure; bar( EF.(EventFileLabel) ); title( sum( EF.(EventFileLabel) ) );
results = evalFallMatFile( FallMat, EF, 'EventFileLabel', EventFileLabel, 'FrameHz', FrameHz, 'sigma_frame', sigma_frame, 'WindowSec', WindowSec, 'ShowType', 'ROIxTIME' );
results = evalFallMatFile( FallMat, EF, 'EventFileLabel', EventFileLabel, 'FrameHz', FrameHz, 'sigma_frame', sigma_frame, 'WindowSec', WindowSec, 'ShowType', 'TRIALxTIME' );
results = evalFallMatFile( FallMat, EF, 'EventFileLabel', EventFileLabel, 'FrameHz', FrameHz, 'sigma_frame', sigma_frame, 'WindowSec', WindowSec, 'ShowType', 'TrialTraces' );
results = evalFallMatFile( FallMat, EF, 'EventFileLabel', EventFileLabel, 'FrameHz', FrameHz, 'sigma_frame', sigma_frame, 'WindowSec', WindowSec, 'ShowType', 'TrialTracesTrain' );

[ val, idx ] = sort( mean( results.EventAligned_FrameBase.dFvalMat_ROIxTime_mean_smoothed, 2 ) ); % figure; plot( results.EventAligned_FrameBase.X_ValMat, results.EventAligned_FrameBase.dFvalMat_ROIxTime_mean_smoothed( idx(end), : ) );
roi_target = idx(end); evalFallMatFile( FallMat, EF, 'EventFileLabel', EventFileLabel, 'FrameHz', FrameHz, 'sigma_frame', sigma_frame, 'WindowSec', WindowSec, 'ShowType', 'TRIALxTIME', 'roi_target', roi_target );
% > space
figure; for roi = 1:length(FallMat.rois_ok); stat = FallMat.stat{ FallMat.rois_ok(roi) }; scatter( stat.xpix, stat.ypix, 'k.' ); hold on; end
stat = FallMat.stat{ FallMat.rois_ok( idx(end) ) }; scatter( stat.xpix, stat.ypix, 'r.' ); hold on; xlim( [ 0 512 ] ); ylim( [ 0 512 ] );
set( gca, 'Xdir', 'normal', 'Ydir', 'reverse' );


%% eval: HoloStimChecker


% > load Fall.mat
thr_prob_iscell = 0.5;
% thr_prob_iscell = 0;
[ FallMat, ROIinfoTable ] = loadFallMatFile( 'thr_prob_iscell', thr_prob_iscell );
% > load EventFile1D
EF = createEventFile( 'FrameMax', size(FallMat.Fcell,2) );
% >> CSV
parts = strsplit( EF.path_LVMfile, '\' ); THEMA = parts{end};
path_mother = []; for i = 1:length(parts)-1; path_mother = [ path_mother, parts{i}, '\' ]; end; path_mother(end) = []; 
NAME = [ 'EventFile1D_', strrep( THEMA, '.lvm', '.csv' ) ];             
path_writematrix = [ fullfile( path_mother, NAME ) ];
writematrix( EF.EventFile1D, path_writematrix );
% >> NPY
cd(anaconda);
path_command = 'python G:\マイドライブ\SharedCodesSmee\tool\';
command = 'CSVtoNPY_infolder.py';
status = dos( [ path_command, command ] ) 


WindowSec = [ -3 10 ];
ShowType = 'ROIxTIME';
ShowType = 'TRIALxTIME';
% ShowType = 'TrialTraces';
% ShowType = 'TrialTracesTrain';
results = evalFallMatFile( FallMat, 'EventFile', EF.EventFile1D, 'WindowSec', WindowSec, 'ShowType', ShowType );


% > Space
St = results.EventAlign.XXX;
fMat = St.dFvalMat_ROIxTime_mean_smoothed;
X = St.X_ValMat;
winX_StimDur = [ 0 10 ];
[ flag_X, X_valid, Y_valid ] = getWinFlagX( X, winX_StimDur, 'Y', fMat );
fMat_StimDur = fMat(:,flag_X); X_StimDur = X(flag_X);
% [ sortedMat, orderMax, valMax_sort, idxMax_sort, valMin_sort, idxMin_sort ] = sortMat(fMat_StimDur);  
% figure; imagesc(sortedMat);

Cvals = nansum( fMat_StimDur, 2 );
Clim = [ -5 5 ];
Cround = 1;
results = evalFallMatFile( FallMat, 'EvalType', 'Space',...
'rois_target', FallMat.rois_ok,...
'Cvals', Cvals,...
'Clim', Clim,...
'Cround', Cround );

figure; FS = 16;
imagesc(results.Cimg);
% set( gca, 'FontSize', FS, 'Ydir', 'normal', 'Xcolor', 'none', 'Ycolor', 'none' );
set( gca, 'FontSize', FS, 'Xcolor', 'none', 'Ycolor', 'none' );
colorbar;
YTcm('whitejet');


%% pop: PiezoStimGo


MS = ManualSettings_ShibushitaPiezoStim;


set_results = {}; 
for ise = 1:size(MS.SessionTable,1)
    %%
    
    % > load Fall.mat
    path_FallMat = MS.SessionTable.Path_FallMat{ise};
    [ FallMat, ROIinfoTable ] = loadFallMatFile( 'path_FallMatfile', path_FallMat );
    disp(path_FallMat);
    % > load EventFile1D <-- Gdrive
    EF = createEventFile( 'Protocol', 'ShibuPiezoStim', 'SessionID', MS.SessionTable.SessionID{ise} ); 
    % > mean&smoothed ValMat around trigger
    NeuroSt = evalFallMatFile( FallMat, EF,...
    'EventFileLabel', [ "EventFile1D_PiezoStim", "EventFile1D_LicksAtFrame" ],...
    'ShowType', 'ROIxTIME' ); % 'TrialTracesTrain'
   
    set_results{ise,1} = FallMat;
    set_results{ise,2} = ROIinfoTable;
    set_results{ise,3} = NeuroSt;
    
    nowfor( ise, size(MS.SessionTable,1) );
end
disp('Complete!');


% > pop: basic
id_target = find( contains( MS.SessionTable.SessionType, 'StimOnly' ) );
id_target = find( contains( MS.SessionTable.SessionType, 'StimGo' ) & ~contains( MS.SessionTable.SessionType, 'seqStimGo' ) );
SessionID = MS.SessionTable.SessionID(id_target);
Nroi = []; fMat = []; sgEx_flag = []; sgIn_flag = [];
for ise = 1:length(id_target)
    FallMat = set_results{ise,1};
    results = set_results{ise,3};
    Nroi = [ Nroi; FallMat.Nroi_ok ];
%     results = evalFallMatFile( FallMat, 'EventFile', EF.EventFile1D.PiezoStim, 'ShowType', 'ROIxTIME' );
    fMat = [ fMat; results.EventAlign.XXX.dFvalMat_ROIxTime_mean_smoothed ];

    SessionID{ise}
    sgEx_flag = [ sgEx_flag; results.EventAlign.XXX.sgEx_flag ]; results.EventAlign.XXX.sgEx_per
    sgIn_flag = [ sgIn_flag; results.EventAlign.XXX.sgIn_flag ]; results.EventAlign.XXX.sgIn_per
end
sum(Nroi)

sum(sgEx_flag==1) / length(sgEx_flag) * 100
sum(sgIn_flag==1) / length(sgIn_flag) * 100

% figure; FS = 16;
% X = results.EventAlign.XXX.X_ValMat;
% winX = [ 0 3 ];
% [ flag_X, X_valid, Y_valid ] = getWinFlagX( X, winX );
% imagesc( X, 1:size(fMat,1), sortMat( fMat, 'flag_valid', flag_X, 'format', 'MaxMin' ) );
% xlim( [ -2 4 ] ); caxis( [ -2 2 ] );
% set( gca, 'FontSize', FS, 'Ydir', 'normal' );
% YTcm('fireice');

% Nclust = 7;
% [ flag_X, X_valid, Y_valid ] = getWinFlagX( X, [ -2 4 ], 'Y', fMat );
% CL = clustFiringPattern( Y_valid, 'method', 'hierarchical', 'Nclust', Nclust,...
% 'PCA', 'PCA', 'PCAuse', 1:3, 'show', 'on', 'ColorThreshold', 0.03,... 0.03
% 'colormap', 'fireice', 'caxis', [ -2 2 ] );


%% > eval: fMat ∝ learning


NtrialUnit = 30;
winX_StimDur = [ 0 1 ];
winX_RespDur = [ .5 1 ];
winX_OutcomeDur = [ 1 2 ];
winX_1trial = [ -.5 2 ]; % preStim ... [ -.5 0 ]?
LW = 2;


id_target = find( contains( MS.SessionTable.AnimalID, 'PS05' ) & contains( MS.SessionTable.SessionType, 'StimGo' ) & ~contains( MS.SessionTable.SessionType, 'seqStimGo' ) );
id_target = find( contains( MS.SessionTable.AnimalID, 'PS06' ) & contains( MS.SessionTable.SessionType, 'StimGo' ) & ~contains( MS.SessionTable.SessionType, 'seqStimGo' ) );
id_target = find( contains( MS.SessionTable.AnimalID, 'PS07' ) & contains( MS.SessionTable.SessionType, 'StimGo' ) & ~contains( MS.SessionTable.SessionType, 'seqStimGo' ) );
Per = []; for ise = 1:length(id_target); St = set_results{ id_target(ise), 3 }.EventAlign.XXX; Per = [ Per; [ St.sgEx_per St.sgIn_per ] ]; end
SessionID = MS.SessionTable.SessionID(id_target);

for ise = 1:length(id_target)
    %%
    St = set_results{ id_target(ise), 3 }.EventAlign.XXX; % list_path_FallMatFile(i,1)

    X = St.X_ValMat;
    rois_target = find(St.sgEx_flag);
%     St.sgEx_per    
    Nroi = length(rois_target);
    for idx = 1:Nroi % roi-loop % idx = 6 % PS07
        %%
        roi = rois_target(idx);        
%         [ flag_X, X_valid, Y_valid ] = getWinFlagX( X, winX_StimDur, 'Y', St.sgEx_01matSet{roi} );
%         SgByTriggers01 = nansum(Y_valid,2) > 0; hold on; plot(SgByTriggers01);

        dFvalMat = St.dFvalMatSet{roi}; Ymean_StimDur_trial = []; % figure; imagesc(dFvalMat);
%         figure; imagesc( X, 1:size(dFvalMat,1), dFvalMat );
        if NtrialUnit < St.Ntrigger
            Nloop = ( St.Ntrigger - NtrialUnit + 1 ); Colors = YTcm( 'viridis', 'Nbin', Nloop, 'setgca', 'off' );        
    %         cla;
            X_trial = [];
            MeanMat = []; SmoothedMeanMat = [];
            for t = 1:Nloop
                S = t; E = S + NtrialUnit - 1; X_trial(1,t) = E;
                TargetMat = dFvalMat(S:E,:); dt_frame = 1; sigma_frame = 3;
                [ Mean, Mean_smoothed, Sem_smoothed ] = binraster2psth_YTcopy( TargetMat, dt_frame, sigma_frame, { 1:size( TargetMat, 1 ) }, ones( size( TargetMat, 1 ), 1 ) ); % from cellBase
                MeanMat = [ MeanMat; Mean ];
                SmoothedMeanMat = [ SmoothedMeanMat; Mean_smoothed ];             
                hold on; plot( X, Mean_smoothed, 'Color', Colors(t,:), 'LineWidth', LW ); xlim(winX_1trial); xlabel('Time from stimulus (sec)'); ylabel('ΔF/F0');
%                 hold on; plot( X, Mean, 'Color', Colors(t,:) ); xlim(winX_1trial);
%                 [ flag_X, X_valid, Y_valid ] = getWinFlagX( X, winX_StimDur, 'Y', Sem_smoothed ); Y_trial(1,t) = nanmean(Y_valid);
%                 hold on; plot( X, Sem_smoothed, 'Color', Colors(t,:), 'linewidth', LW ); ylabel('ΔF/F');
            end
            % figure; imagesc( X, X_trial, MeanMat ); xlim(winX_1trial);
            % figure; imagesc( X, X_trial, SmoothedMeanMat ); xlim(winX_1trial);
            % hold on; plot( X_trial, Y_trial );
        end

        % > stat        
        [ flag_X, X_StimDur, Y_StimDur ] = getWinFlagX( X, winX_StimDur, 'Y', dFvalMat );
        YmeanTrials_StimDur = nanmean(Y_StimDur,2);
        [ flag_X, X_OutcomeDur, Y_OutcomeDur ] = getWinFlagX( X, winX_OutcomeDur, 'Y', dFvalMat );
        YmeanTrials_OutcomeDur = nanmean(Y_OutcomeDur,2);                
        Xtrials = ( 1:length(YmeanTrials_StimDur) )';
        [ rho_StimDur(idx,1), p_StimDur(idx,1) ] = corr( Xtrials,  YmeanTrials_StimDur, 'Type', 'Spearman' );
        [ rho_OutcomeDur(idx,1), p_OutcomeDur(idx,1) ] = corr( Xtrials, YmeanTrials_OutcomeDur, 'Type', 'Spearman' );            
%         figure(1); cla;
%         plot( Xtrials, YmeanTrials_StimDur, 'r' ); hold on;
%         plot( Xtrials, YmeanTrials_OutcomeDur, 'b' );
%         TITLE = [ 'CS: rho = ', num2str( rho_StimDur(idx,1) ), ' (p = ', num2str( p_StimDur(idx,1) ), ') | US: rho = ', num2str( rho_OutcomeDur(idx,1) ), ' (p = ', num2str( p_OutcomeDur(idx,1) ), ')' ];
%         title(TITLE); 


    end
%     figure; histogram(rho_StimDur);
%     figure; histogram(rho_OutcomeDur);
%       figure; LWbold = 3;
%       for i = 1:length(rho_StimDur); plot( [ 1 2 ], [ rho_StimDur(i), rho_OutcomeDur(i) ] ); hold on; end; plot( [ 1 2 ], nanmean( [ rho_StimDur, rho_OutcomeDur ] ), 'k', 'Linewidth', LWbold );

thr_p = 0.01;
[ nansum( (rho_StimDur>=0)&(p_StimDur<thr_p) )/Nroi*100,... CS-+
  nansum( (rho_StimDur<0)&(p_StimDur<thr_p) )/Nroi*100,...
  nansum( (rho_OutcomeDur>=0)&(p_OutcomeDur<thr_p) )/Nroi*100,...
  nansum( (rho_OutcomeDur<0)&(p_OutcomeDur<thr_p) )/Nroi*100 ]  % US+-

   
end



%% >> eval: Space1


X = St.X_ValMat;
id_target = id_StimGoSession;
% id_target = id_SeqStimGoSession;
for i = 1:length(id_target)
    %%
    parts = strsplit( list_path_FallMatFile{ id_target(i) }, '_' );
    SessionID = [ parts{4}, ' ', parts{5}(1:6) ];
    St = set_results{ id_target(i), 4 }.EventAlign.XXX;
    fMat = St.dFvalMat_ROIxTime_mean_smoothed; % figure; imagesc(fMat);
    FallMat = set_results{ id_target(i), 1 }; % list_path_FallMatFile(i,1) 
    Stat = FallMat.stat(FallMat.rois_ok);

    %%% define color
    CLIM = [ -1 1 ]; Vround = 1;
    winX_StimDur = [ 0 3 ];
    [ flag_X, X_valid, Y_valid ] = getWinFlagX( X, winX_StimDur, 'Y', fMat );
    fMat_StimDur = fMat(:,flag_X);
    X_StimDur = X(flag_X);
    Cval = nanmean(fMat_StimDur,2); % figure; histogram(Cval);
    if isnan(Cval); Cval( isnan(Cval) ) = 0; end
    Cval_adj = round( Cval, 1 ); Cval_adj( Cval_adj < CLIM(1) ) = CLIM(1); Cval_adj( CLIM(2) < Cval_adj ) = CLIM(2);
    % figure; histogram(cval_adj);
    switch Vround
        case 1; Crange = round( CLIM(1):0.1:CLIM(2), 1 ); Nbin = length(Crange);
    end
    FaceColors = YTcm( 'fireice', 'Nbin', Nbin, 'setgca', 'off' );  
    %%%

    figure; FS = 16;
%     I = zeros( 512, 512 );
    for roi = 1:length(Stat)
%         J = regionfill(I,Stat{roi}.xpix, Stat{roi}.ypix); figure; imagesc(J);
        RGB = FaceColors( Crange==Cval_adj(roi), : ); 
        scatter( Stat{roi}.xpix, Stat{roi}.ypix, [], RGB, '.' ); hold on;
    end
    caxis( [ -1 1 ] );
    set( gca, 'FontSize', FS, 'Ydir', 'normal', 'Xcolor', 'none', 'Ycolor', 'none' );
    xlim( [ 0 512 ] ); ylim( [ 0 512 ] );
    title(SessionID);

end


%% >> eval: Space2


Cvals = 1;
Clim = [ 0 1 ];
Cround = 1;


id_target = id_PS05_StimGoSessions; ANIMAL = "PS05";
% id_target = id_PS06_StimGoSessions; ANIMAL = "PS06";
% id_target = id_PS07_StimGoSessions; ANIMAL = "PS07";
Cimg_sum = zeros( 512, 512 );
for i = 1:length(id_target)
    FallMat = set_results{ id_target(i), 1 };
    results = evalFallMatFile( FallMat, 'EvalType', 'Space',...
    'rois_target', FallMat.rois_ok,...
    'Cvals', Cvals,...
    'Clim', Clim,...
    'Cround', Cround );
    Cimg_sum = Cimg_sum + results.Cimg;
end


figure; FS = 16;
imagesc(Cimg_sum);
set( gca, 'FontSize', FS, 'Ydir', 'normal', 'Xcolor', 'none', 'Ycolor', 'none' );
colorbar;
YTcm('whitejet');
title(ANIMAL);


%% Behav


path_SummaryMat = 'G:\マイドライブ\database\database_Shibushita-PiezoStim\EventFile_PS05-06-07_CSV-NPYfiles\summary_database';
LOAD = load(path_SummaryMat); KondoSt = LOAD.KondoSt;


se = 2; KondoSt.each_trial_data(:,1)
se = 6;
se = 9;
se = 12;


CorrectTable = KondoSt.each_trial_data{se,2};
Correct = CorrectTable.Success;
licking_data = KondoSt.licking_data;
% Spoint = 20; figure; plot( smoothdata( Correct, 'gaussian', Spoint ) );


LickTable = licking_data{se,2};
X = LickTable.Time;
LickCount = LickTable.Total_Licking; LickCount(1) = 0;
%%%
LickSum = LickCount(end); LickOn = zeros( size(LickCount) );
for l = 1:LickSum
    cands = find(LickCount==l); if ~isempty(cands); LickOn( cands(1) ) = 1; end % lick-detection miss?
end
%%%
TrialNum = LickTable.("Nth Trial"); 
X_StimOn = []; X_ChoiceOn = [];
for trial = 1:TrialNum(end)
    X_loval = X(TrialNum==trial); 
    PiezoOn_local = LickTable.PiezoOn(TrialNum==trial); 
    JudgeOn_local = LickTable.JudgeTime(TrialNum==trial); 
    cands = find(PiezoOn_local==1); X_StimOn = [ X_StimOn; X_loval( cands(1) ) ];
    cands = find(JudgeOn_local==1); X_ChoiceOn = [ X_ChoiceOn; X_loval( cands(1) ) ];
end
%%%


% %
% check lick
%%%
WindowSec = [ -1.2 1.5 ];
sigma = 0.05;
%%%

YLIM = [ 0 10 ];

ValTrain = LickOn;
X_ValTrain = X; 
X_Trigger = X_ChoiceOn;
X_Trigger = X_StimOn;
LickSt = calValMatAroundTrigger( ValTrain, X_ValTrain, X_Trigger, 'WindowSec', WindowSec, 'sigma', sigma );
figure(1); % cla;
plot( LickSt.X_ValMat, LickSt.ValMat_mean_smoothed ); hold on;
xlim(WindowSec); ylim(YLIM);


%% ref


% t-SNE <<< figPiece_showCellType_nLOT
% % > show
% iAX = iAXstart;
% iAX = iAX + 1; axes(ax(iAX)); hold on;     
% set( gca, 'box', 'off', 'FontSize', params.FS );    
% rng(1); % fix
% Y = tsne( featureMat );
% gs = gscatter( Y(:,1), Y(:,2), V.class.ROCepoch.string_CStype );
% % >> set color
% for i = 1:length(gs)
%     gs(i).MarkerSize = params.MS;
%     switch gs(i).DisplayName
%         case 'Go-Cue preferred neurons'
%             gs(i).Color = YTc( V.class.ROCepoch.CLset_char(1) );
%         case 'No-Go-Cue preferred neurons'
%             gs(i).Color = YTc( V.class.ROCepoch.CLset_char(2) );
%         case 'Cue excitatory neurons'
%             gs(i).Color = YTc( V.class.ROCepoch.CLset_char(3) );
%         case 'Cue inhibitory neurons'
%             gs(i).Color = YTc( V.class.ROCepoch.CLset_char(4) );
%         case 'Cue non-selective neurons'
%             gs(i).Color = YTc( V.class.ROCepoch.CLset_char(5) );            
%     end
% end
% legend off;
% xlabel( 'tSNE 1', 'FontSize', params.LS );
% ylabel( 'tSNE 2', 'FontSize', params.LS );


%%


FallSt_target = load("D:\database_local\database_Shibushita-PiezoStim_221017\PS09\suite2p_PS09_220726_sponta\plane0\Fall.mat"); % GCaMP: sender
FallSt_buddy = load("D:\database_local\database_Shibushita-PiezoStim_221017\PS08\suite2p_PS08_220726_sponta\plane0\Fall.mat");  % ChRmine: receiver
TraceMat_target = FallSt_target.F - FallSt_target.Fneu*.7;
TraceMat_buddy = FallSt_buddy.F - FallSt_buddy.Fneu*.7;


TraceMat_target = TraceMat_target'; TraceMat_target(isnan(TraceMat_target)) = 0;
TraceMat_buddy = TraceMat_buddy'; TraceMat_buddy(isnan(TraceMat_buddy)) = 0;
[ R, P ] = corr( TraceMat_target./max(max(TraceMat_target)), TraceMat_buddy./max(max(TraceMat_buddy)) ); figure; imagesc(R);  


% D = diag( ones(size(R,1), 1) );
% Rpair = R(D==1);
% Rother = reshape(R(D==0), [], 1);
% disp([ mean(Rpair) mean(Rother) ]);


end


% program end
